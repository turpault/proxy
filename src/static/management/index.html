<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proxy Server Management</title>
  <!-- ECharts CDN for world map heatmap -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/extension/dataTool.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/extension/bmap.min.js"></script>
  <!-- <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/map/js/world.js"></script> -->
  <!-- Removed world.js due to MIME type issues - will use built-in world map data -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: #f5f7fa;
      color: #2d3748;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Tab bar styles */
    .tab-bar {
      display: flex;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 8px 8px 0 0;
      overflow: hidden;
      margin-bottom: 2rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.08);
    }

    .tab {
      flex: 1;
      padding: 1.2rem 0;
      text-align: center;
      color: #fff;
      font-size: 1.2rem;
      font-weight: 600;
      cursor: pointer;
      background: none;
      border: none;
      outline: none;
      transition: background 0.2s, color 0.2s;
    }

    .tab.active {
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    .tab:not(.active):hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 2rem;
    }

    .header-left {
      flex: 1;
    }

    .header-right {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      min-width: 200px;
    }

    .last-updated-info {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
    }

    .last-updated-label {
      font-size: 0.8rem;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .last-updated-time {
      font-size: 0.9rem;
      font-weight: 500;
      opacity: 0.9;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    .header p {
      opacity: 0.9;
      font-size: 1.1rem;
    }

    .connection-status {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-weight: 500;
      font-size: 0.9rem;
      display: inline-block;
    }

    .connection-status.connected {
      background: rgba(34, 197, 94, 0.1);
      color: #16a34a;
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .connection-status.disconnected {
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .status-cards,
    .stats-overview {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .card,
    .stat-card {
      background: white;
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
    }

    .card h3,
    .stat-card h4 {
      color: #4a5568;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .card .value,
    .stat-card .value {
      font-size: 2rem;
      font-weight: bold;
      color: #2d3748;
    }

    .refresh-btn {
      background: #4299e1;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.2s;
    }

    .refresh-btn:hover {
      background: #3182ce;
    }

    .refresh-btn:disabled {
      background: #a0aec0;
      cursor: not-allowed;
    }

    .processes-section,
    .routes-section,
    .certificates-section {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      margin-bottom: 2rem;
    }

    .processes-section h2,
    .routes-section h2,
    .certificates-section h2 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1.5rem;
    }

    .section-description {
      color: #718096;
      font-size: 0.95rem;
      margin-bottom: 1.5rem;
      font-style: italic;
    }

    .process {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      transition: box-shadow 0.2s;
    }

    .process:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .process-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 1rem;
      min-height: 4rem;
      gap: 1rem;
      transition: all 0.2s ease;
      border: 1px solid #e2e8f0;
      cursor: pointer;
      position: relative;
    }

    .process-header:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      transform: translateY(-1px);
    }

    .process-header::after {
      content: 'â–¼';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
      color: #718096;
      font-size: 0.8rem;
      transition: transform 0.2s ease;
    }

    .process-header.expanded::after {
      transform: translateY(-50%) rotate(180deg);
    }

    .process-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 3rem;
    }

    .process-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.5rem;
      line-height: 1.2;
    }

    .process-details {
      font-size: 0.9rem;
      color: #718096;
      margin-top: 0.25rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: flex-start;
    }

    .process-details span {
      white-space: nowrap;
      min-width: fit-content;
      height: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.25rem 0.5rem;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #e9ecef;
      font-weight: 500;
      font-size: 0.85rem;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      line-height: 1;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 1rem;
    }

    .process-details span.success {
      background: #d4edda;
      border-color: #c3e6cb;
      color: #155724;
    }

    .process-details span.warning {
      background: #fff3cd;
      border-color: #ffeaa7;
      color: #856404;
    }

    .process-details span.error {
      background: #f8d7da;
      border-color: #f5c6cb;
      color: #721c24;
    }

    .process-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: bold;
      text-transform: uppercase;
    }

    .status-running {
      background: #c6f6d5;
      color: #22543d;
    }

    .status-stopped {
      background: #fed7d7;
      color: #742a2a;
    }

    .status-warning {
      background: #fef5e7;
      color: #744210;
    }

    .status-error {
      background: #fed7d7;
      color: #742a2a;
    }

    .process-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      min-height: 3rem;
      justify-content: flex-end;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.9rem;
      transition: all 0.2s;
      height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 80px;
      white-space: nowrap;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-start {
      background: #48bb78;
      color: white;
    }

    .btn-start:hover:not(:disabled) {
      background: #38a169;
    }

    .btn-stop {
      background: #f56565;
      color: white;
    }

    .btn-stop:hover:not(:disabled) {
      background: #e53e3e;
    }

    .btn-restart {
      background: #ed8936;
      color: white;
    }

    .btn-restart:hover:not(:disabled) {
      background: #dd6b20;
    }

    .btn-logs {
      background: #4299e1;
      color: white;
    }

    .btn-logs:hover {
      background: #3182ce;
    }

    .process-body {
      padding: 1rem;
      display: none;
    }

    .process-body.expanded {
      display: block;
    }

    .process-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .metric {
      text-align: center;
    }

    .metric-label {
      font-size: 0.8rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metric-value {
      font-size: 1.2rem;
      font-weight: bold;
      padding: 1rem;
      color: #2d3748;
    }

    .metric-value.warning {
      color: #d69e2e;
    }

    .metric-value.error {
      color: #e53e3e;
    }

    .metric-value.success {
      color: #38a169;
    }

    .restart-history {
      background: #f7fafc;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .restart-history h4 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .restart-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid #e2e8f0;
    }

    .restart-item:last-child {
      border-bottom: none;
    }

    .restart-time {
      font-size: 0.9rem;
      color: #4a5568;
    }

    .restart-count {
      font-weight: bold;
      color: #2d3748;
    }

    .logs-container {
      background: #1a202c;
      color: #e2e8f0;
      border-radius: 6px;
      padding: 1rem;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.3;
      position: relative;
    }

    .logs-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #4a5568;
    }

    .logs-title {
      font-weight: bold;
      color: #e2e8f0;
    }

    .logs-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
    }

    .logs-controls select {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
    }

    .logs-filter-buttons {
      display: flex;
      gap: 0.25rem;
    }

    .logs-filter-btn {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .logs-filter-btn:hover {
      background: #4a5568;
    }

    .logs-filter-btn.active {
      background: #4299e1;
      border-color: #4299e1;
    }

    .logs-filter-btn.all {
      background: #48bb78;
      border-color: #48bb78;
    }

    .logs-filter-btn.all.active {
      background: #38a169;
      border-color: #38a169;
    }

    .logs-filter-btn.stdout {
      background: #4299e1;
      border-color: #4299e1;
    }

    .logs-filter-btn.stdout.active {
      background: #3182ce;
      border-color: #3182ce;
    }

    .logs-filter-btn.stderr {
      background: #f56565;
      border-color: #f56565;
    }

    .logs-filter-btn.stderr.active {
      background: #e53e3e;
      border-color: #e53e3e;
    }

    .logs-since-restart {
      background: #805ad5;
      border-color: #805ad5;
    }

    .logs-since-restart.active {
      background: #6b46c1;
      border-color: #6b46c1;
    }

    .logs-since-restart:hover {
      background: #6b46c1;
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #48bb78;
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: #48bb78;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    .log-line {
      margin-bottom: 0.1rem;
      word-wrap: break-word;
      padding: 0.05rem 0;
      white-space: pre-wrap;
    }

    .log-line:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .log-line.stdout {
      border-left: 3px solid #4299e1;
      padding-left: 0.5rem;
    }

    .log-line.stderr {
      border-left: 3px solid #f56565;
      padding-left: 0.5rem;
      background: rgba(245, 101, 101, 0.1);
    }

    .log-line.stderr:hover {
      background: rgba(245, 101, 101, 0.15);
    }

    .log-line.hidden {
      display: none;
    }

    .logs-content {
      max-height: 320px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .logs-content::-webkit-scrollbar {
      width: 8px;
    }

    .logs-content::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 4px;
    }

    .logs-content::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }

    .logs-content::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }

    .logs-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #718096;
      font-style: italic;
    }

    .logs-error {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #f56565;
      font-weight: 500;
    }

    /* Time filter styles */
    .time-filter {
      background: white;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
    }

    .time-filter h3 {
      margin-bottom: 1rem;
      color: #2d3748;
    }

    .filter-buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .filter-btn {
      background: #e2e8f0;
      color: #4a5568;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }

    .filter-btn.active {
      background: #4299e1;
      color: white;
    }

    .filter-btn:hover {
      background: #4299e1;
      color: white;
    }

    /* Routes table styles */
    .routes-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }

    .routes-table th,
    .routes-table td {
      padding: 1rem;
      text-align: left;
      border-bottom: 1px solid #e2e8f0;
    }

    .routes-table th {
      background: #f7fafc;
      font-weight: 600;
      color: #4a5568;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .routes-table tr:hover {
      background: #f7fafc;
    }

    .route-domain {
      font-weight: 600;
      color: #2d3748;
    }

    .route-target {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .request-count {
      font-weight: 600;
      color: #2d3748;
    }

    .geolocation {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .country-flag {
      width: 20px;
      height: 15px;
      border-radius: 2px;
      object-fit: cover;
    }

    .country-name {
      font-size: 0.9rem;
      color: #4a5568;
    }

    /* Certificate styles */
    .certificate-card {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease;
    }

    .certificate-card:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    .certificate-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      gap: 1rem;
    }

    .certificate-info {
      flex: 1;
    }

    .certificate-name {
      font-weight: 700;
      color: #1a202c;
      font-size: 1.25rem;
      margin-bottom: 0.5rem;
    }

    .certificate-path {
      font-size: 0.85rem;
      color: #718096;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      word-break: break-all;
    }

    .certificate-status {
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
    }

    .certificate-status.valid {
      background: rgba(34, 197, 94, 0.1);
      color: #16a34a;
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .certificate-status.expired {
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .certificate-status.expiring-soon {
      background: rgba(245, 158, 11, 0.1);
      color: #d97706;
      border: 1px solid rgba(245, 158, 11, 0.2);
    }

    .certificate-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
    }

    .certificate-detail {
      display: flex;
      flex-direction: column;
    }

    .certificate-detail-label {
      font-weight: 600;
      color: #4a5568;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }

    .certificate-detail-value {
      color: #2d3748;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.95rem;
      font-weight: 500;
    }

    .certificate-detail-value.success {
      color: #16a34a;
    }

    .certificate-detail-value.warning {
      color: #d97706;
    }

    .certificate-detail-value.error {
      color: #dc2626;
    }

    .letsencrypt-info {
      background: #f7fafc;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
      border: 1px solid #e2e8f0;
    }

    .letsencrypt-info h4 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .letsencrypt-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      font-size: 0.9rem;
    }

    .letsencrypt-detail {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
    }

    .letsencrypt-detail .label {
      color: #4a5568;
      font-weight: 500;
    }

    .letsencrypt-detail .value {
      color: #2d3748;
      font-weight: 600;
    }

    /* Geolocation heatmap */
    #geo-heatmap {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      margin-bottom: 2rem;
    }

    /* Utility classes */
    .loading {
      text-align: center;
      color: #718096;
      font-style: italic;
    }

    .error {
      background: #fed7d7;
      color: #742a2a;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .success {
      background: #c6f6d5;
      color: #22543d;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1rem 1.5rem;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.3s ease;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background: #48bb78;
    }

    .notification.error {
      background: #f56565;
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }

      .header h1 {
        font-size: 2rem;
      }

      .process-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
        min-height: auto;
        padding: 0.75rem;
      }

      .process-info {
        min-height: auto;
        width: 100%;
      }

      .process-actions {
        flex-wrap: wrap;
        gap: 0.5rem;
        width: 100%;
        justify-content: flex-start;
        min-height: auto;
      }

      .btn {
        height: 2.25rem;
        min-width: 70px;
        font-size: 0.85rem;
        padding: 0.4rem 0.8rem;
      }

      .process-details {
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
        justify-content: flex-start;
      }

      .process-details span {
        font-size: 0.85rem;
        height: 1.4rem;
        padding: 0.2rem 0.4rem;
        width: 100%;
        justify-content: flex-start;
      }

      .routes-table {
        font-size: 0.8rem;
      }

      .routes-table th,
      .routes-table td {
        padding: 0.5rem;
      }

      .letsencrypt-details {
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }

      .letsencrypt-detail {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
      }

      /* New Let's Encrypt config mobile styles */
      .letsencrypt-config {
        padding: 1rem;
        margin-bottom: 1.5rem;
      }

      .letsencrypt-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }

      .letsencrypt-title {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .letsencrypt-title h3 {
        font-size: 1.25rem;
      }

      .letsencrypt-grid {
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }

      .letsencrypt-item {
        padding: 0.75rem;
      }

      .certificate-summary {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
      }

      .certificate-summary-item {
        padding: 0.75rem;
      }

      .certificate-summary-number {
        font-size: 1.5rem;
      }

      /* Route cards mobile styles */
      .route-card {
        padding: 1rem;
        margin-bottom: 0.75rem;
      }

      .route-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .route-domain {
        font-size: 1.1rem;
      }

      .route-stats {
        text-align: left;
        width: 100%;
      }

      .route-details {
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }

      .route-detail-value {
        gap: 0.25rem;
      }

      .country-badge,
      .method-badge {
        font-size: 0.75rem;
        padding: 0.2rem 0.5rem;
      }
    }

    /* Process tabs styles */
    .process-tabs {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }

    .process-tabs-header {
      display: flex;
      background: #f7fafc;
      border-bottom: 1px solid #e2e8f0;
      overflow-x: auto;
    }

    .process-tab {
      padding: 1rem 1.5rem;
      background: transparent;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: #4a5568;
      border-bottom: 3px solid transparent;
      white-space: nowrap;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      min-width: 120px;
    }

    .process-tab:hover {
      background: #edf2f7;
      color: #2d3748;
    }

    .process-tab.active {
      background: white;
      color: #2d3748;
      border-bottom-color: #4299e1;
    }

    .process-tab-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .process-tab-status.running {
      background: #48bb78;
    }

    .process-tab-status.stopped {
      background: #f56565;
    }

    .process-tab-status.warning {
      background: #ed8936;
    }

    .process-tab-content {
      display: none;
      padding: 1rem 0.5rem;
      margin-bottom: 0.5rem;
    }

    .process-tab-content.active {
      display: block;
    }

    .process-tab-header {
      display: flex;
      align-items: flex-start;
      gap: 1rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .process-tab-actions {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #e2e8f0;
      align-items: center;
    }

    .process-tab-actions .btn {
      min-width: 70px;
      font-size: 0.85rem;
      padding: 0.3rem 0.7rem;
      height: 2rem;
    }

    .process-tab-info {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: flex-start;
      flex: 1;
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #e2e8f0;
    }

    .process-tab-info-item {
      background: #f7fafc;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      border: 1px solid #e2e8f0;
      min-width: 120px;
      font-size: 0.85rem;
    }

    .process-tab-section {
      margin-bottom: 1rem;
    }

    .process-tab-section.collapsible {
      display: none;
    }

    .process-tab-section.collapsible.open {
      display: block;
    }

    .process-tab-info-label {
      font-size: 0.8rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }

    .process-tab-info-value {
      font-weight: 500;
      color: #2d3748;
      font-size: 0.9rem;
    }

    .process-tab-info-value.success {
      color: #38a169;
    }

    .process-tab-info-value.warning {
      color: #d69e2e;
    }

    .process-tab-info-value.error {
      color: #e53e3e;
    }

    .process-tab-info-value.time-display {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
      color: #4a5568;
      background: #f7fafc;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
      border: 1px solid #e2e8f0;
    }

    .process-tab-info-value.relative-time {
      font-style: italic;
      color: #718096;
      font-size: 0.8rem;
    }

    .process-tab-section {
      margin-bottom: 2rem;
    }

    .process-tab-section h3 {
      color: #2d3748;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .no-processes-tab {
      padding: 3rem;
      text-align: center;
      color: #718096;
    }

    .no-processes-tab h3 {
      color: #4a5568;
      margin-bottom: 0.5rem;
    }

    .process-tab-scroll {
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: #cbd5e0 #f7fafc;
    }

    .process-tab-scroll::-webkit-scrollbar {
      height: 6px;
    }

    .process-tab-scroll::-webkit-scrollbar-track {
      background: #f7fafc;
    }

    .process-tab-scroll::-webkit-scrollbar-thumb {
      background: #cbd5e0;
      border-radius: 3px;
    }

    .process-tab-scroll::-webkit-scrollbar-thumb:hover {
      background: #a0aec0;
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #48bb78;
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: #48bb78;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .follow-btn {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .follow-btn:hover {
      background: #4a5568;
    }

    .follow-btn.active {
      background: #48bb78;
      border-color: #48bb78;
      color: white;
    }

    .follow-btn.inactive {
      background: #f56565;
      border-color: #f56565;
      color: white;
    }

    .live-indicator.following {
      color: #48bb78;
    }

    .live-indicator.not-following {
      color: #f56565;
    }

    .live-indicator.not-following .live-dot {
      background: #f56565;
    }

    /* Cache Management Styles */
    .cache-controls {
      margin-bottom: 2rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }

    .cache-controls .btn {
      min-width: 120px;
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      height: 2.5rem;
    }

    .cache-controls .refresh-btn {
      min-width: 140px;
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      height: 2.5rem;
    }

    .cache-tabs {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }

    .cache-tabs-header {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #e2e8f0;
    }

    .cache-tab {
      flex: 1;
      padding: 1rem;
      text-align: center;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      color: #4a5568;
      transition: all 0.2s;
      border-bottom: 3px solid transparent;
    }

    .cache-tab:hover {
      background: #e2e8f0;
      color: #2d3748;
    }

    .cache-tab.active {
      background: white;
      color: #4299e1;
      border-bottom-color: #4299e1;
    }

    .cache-tab-content {
      display: none;
      padding: 2rem;
    }

    .cache-tab-content.active {
      display: block;
    }

    .cache-section {
      margin-bottom: 2rem;
    }

    .cache-section h2 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1.5rem;
    }

    .cache-filters {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .filter-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .filter-group label {
      font-weight: 500;
      color: #4a5568;
      white-space: nowrap;
    }

    .filter-group select {
      padding: 0.5rem;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      background: white;
      font-size: 0.9rem;
      min-width: 120px;
    }

    .cache-pagination {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .cache-pagination button {
      padding: 0.5rem 1rem;
      border: 1px solid #e2e8f0;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .cache-pagination button:hover:not(:disabled) {
      background: #f8f9fa;
    }

    .cache-pagination button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .cache-pagination span {
      font-weight: 500;
      color: #4a5568;
    }

    .cache-entry {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      background: white;
      transition: box-shadow 0.2s;
    }

    .cache-entry:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .cache-entry-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background: #f8f9fa;
      border-bottom: 1px solid #e2e8f0;
    }

    .cache-entry-info {
      flex: 1;
    }

    .cache-entry-url {
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.25rem;
      word-break: break-all;
    }

    .cache-entry-meta {
      display: flex;
      gap: 1rem;
      font-size: 0.85rem;
      color: #718096;
      flex-wrap: wrap;
    }

    .cache-entry-actions {
      display: flex;
      gap: 0.5rem;
    }

    .cache-entry-body {
      padding: 1rem;
    }

    .cache-entry-preview {
      background: #f8f9fa;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .cache-user-card {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      background: white;
      transition: box-shadow 0.2s;
    }

    .cache-user-card:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .cache-user-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .cache-user-id {
      font-weight: 600;
      color: #2d3748;
      font-size: 1.1rem;
    }

    .cache-user-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .cache-user-stat {
      text-align: center;
      padding: 0.75rem;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .cache-user-stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #2d3748;
    }

    .cache-user-stat-label {
      font-size: 0.8rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .cache-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .cache-stat-item {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
    }

    .cache-stat-value {
      font-size: 2rem;
      font-weight: bold;
      color: #2d3748;
      margin-bottom: 0.5rem;
    }

    .cache-stat-label {
      font-size: 0.9rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .cache-stat-description {
      font-size: 0.8rem;
      color: #a0aec0;
      margin-top: 0.5rem;
    }

    .loading {
      text-align: center;
      padding: 2rem;
      color: #718096;
      font-style: italic;
    }

    .error-message {
      background: #fed7d7;
      border: 1px solid #f5c6cb;
      color: #721c24;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
    }

    .success-message {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
    }

    /* Let's Encrypt Configuration Styles */
    .letsencrypt-config {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      color: white;
      box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
      position: relative;
      overflow: hidden;
    }

    .letsencrypt-config::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="10" r="0.5" fill="white" opacity="0.1"/><circle cx="10" cy="60" r="0.5" fill="white" opacity="0.1"/><circle cx="90" cy="40" r="0.5" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
      pointer-events: none;
    }

    .letsencrypt-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      position: relative;
      z-index: 1;
    }

    .letsencrypt-title {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .letsencrypt-icon {
      font-size: 2rem;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .letsencrypt-title h3 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 700;
      color: white;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .letsencrypt-subtitle {
      margin: 0.25rem 0 0 0;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.8);
      font-weight: 400;
    }

    .letsencrypt-status-badge {
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .letsencrypt-status-badge.production {
      background: rgba(34, 197, 94, 0.2);
      color: #4ade80;
    }

    .letsencrypt-status-badge.staging {
      background: rgba(245, 158, 11, 0.2);
      color: #fbbf24;
    }

    .letsencrypt-content {
      position: relative;
      z-index: 1;
    }

    .letsencrypt-section {
      margin-bottom: 1.5rem;
    }

    .letsencrypt-section:last-child {
      margin-bottom: 0;
    }

    .letsencrypt-section h4 {
      margin: 0 0 1rem 0;
      font-size: 1rem;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .letsencrypt-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1rem;
    }

    .letsencrypt-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease;
    }

    .letsencrypt-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .letsencrypt-item-icon {
      font-size: 1.25rem;
      width: 2rem;
      height: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 6px;
    }

    .letsencrypt-item-content {
      flex: 1;
    }

    .letsencrypt-item-label {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.7);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }

    .letsencrypt-item-value {
      font-size: 0.95rem;
      font-weight: 600;
      color: white;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }

    .certificate-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
    }

    .certificate-summary-item {
      text-align: center;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease;
    }

    .certificate-summary-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
    }

    .certificate-summary-item.valid {
      border-color: rgba(34, 197, 94, 0.3);
      background: rgba(34, 197, 94, 0.1);
    }

    .certificate-summary-item.warning {
      border-color: rgba(245, 158, 11, 0.3);
      background: rgba(245, 158, 11, 0.1);
    }

    .certificate-summary-item.error {
      border-color: rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.1);
    }

    .certificate-summary-number {
      font-size: 2rem;
      font-weight: 700;
      color: white;
      margin-bottom: 0.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .certificate-summary-label {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.8);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }

    /* Route statistics styles */
    .route-card {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease;
    }

    .route-card:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    .route-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      gap: 1rem;
    }

    .route-info {
      flex: 1;
    }

    .route-domain {
      font-weight: 700;
      color: #1a202c;
      font-size: 1.25rem;
      margin-bottom: 0.5rem;
    }

    .route-target {
      color: #4a5568;
      font-size: 0.95rem;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }

    .route-stats {
      text-align: right;
    }

    .route-requests {
      font-weight: 600;
      color: #2b6cb0;
      font-size: 1.1rem;
      margin-bottom: 0.25rem;
    }

    .route-response-time {
      color: #718096;
      font-size: 0.9rem;
    }

    .route-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .route-detail {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .route-detail-label {
      font-weight: 600;
      color: #4a5568;
      font-size: 0.9rem;
    }

    .route-detail-value {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .country-badge {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .method-badge {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }

    .no-data {
      color: #a0aec0;
      font-style: italic;
      font-size: 0.9rem;
    }

    /* Time period display */
    #time-period {
      color: #718096;
      font-size: 0.9rem;
      text-align: center;
      margin-bottom: 1rem;
    }

    .route-group {
      margin-bottom: 2.5rem;
    }

    .route-group-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: #4a5568;
      margin-bottom: 1rem;
      border-left: 4px solid #667eea;
      padding-left: 0.75rem;
      letter-spacing: 0.5px;
    }

    .route-group-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
    }

    @media (max-width: 768px) {
      .route-group-cards {
        flex-direction: column;
        gap: 0.75rem;
      }

      .route-group-title {
        font-size: 1.1rem;
        margin-bottom: 0.5rem;
        padding-left: 0.5rem;
      }
    }

    /* Configuration Editor Styles */
    .config-tabs {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }

    .config-tabs-header {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #e2e8f0;
    }

    .config-tab {
      flex: 1;
      padding: 1rem;
      text-align: center;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      color: #4a5568;
      transition: all 0.2s;
      border-bottom: 3px solid transparent;
    }

    .config-tab:hover {
      background: #e2e8f0;
      color: #2d3748;
    }

    .config-tab.active {
      background: white;
      color: #4299e1;
      border-bottom-color: #4299e1;
    }

    .config-tab-content {
      display: none;
      padding: 2rem;
    }

    .config-tab-content.active {
      display: block;
    }

    .config-section {
      margin-bottom: 2rem;
    }

    .config-section h2 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1.5rem;
    }

    .config-controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .config-controls .btn {
      min-width: 120px;
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      height: 2.5rem;
    }

    .config-controls .refresh-btn {
      min-width: 140px;
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      height: 2.5rem;
    }

    .config-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }

    .config-info-item {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .config-info-item label {
      font-weight: 600;
      color: #4a5568;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .config-info-item span {
      color: #2d3748;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
      word-break: break-all;
    }

    .config-editor-container {
      margin-bottom: 1.5rem;
    }

    .config-editor {
      width: 100%;
      min-height: 500px;
      padding: 1rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      background: #f8f9fa;
      color: #2d3748;
      resize: vertical;
      outline: none;
      transition: border-color 0.2s;
    }

    .config-editor:focus {
      border-color: #4299e1;
      background: white;
    }

    .config-editor::placeholder {
      color: #a0aec0;
    }

    .config-validation {
      margin-bottom: 1rem;
    }

    .validation-message {
      padding: 0.75rem;
      border-radius: 4px;
      font-weight: 500;
      font-size: 0.9rem;
    }

    .validation-message.success {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }

    .validation-message.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }

    .validation-message.warning {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      color: #856404;
    }

    /* Backup Modal Styles */
    .backup-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .backup-modal-content {
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      border-radius: 8px;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }

    .backup-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #e2e8f0;
    }

    .backup-modal-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #2d3748;
    }

    .backup-modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #718096;
      padding: 0.5rem;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .backup-modal-close:hover {
      background: #f7fafc;
      color: #4a5568;
    }

    .backup-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .backup-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      margin-bottom: 0.75rem;
      background: white;
      transition: all 0.2s;
    }

    .backup-item:hover {
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border-color: #cbd5e0;
    }

    .backup-info {
      flex: 1;
    }

    .backup-name {
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.25rem;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
    }

    .backup-meta {
      font-size: 0.8rem;
      color: #718096;
    }

    .backup-actions {
      display: flex;
      gap: 0.5rem;
    }

    .backup-actions .btn {
      min-width: 80px;
      font-size: 0.85rem;
      padding: 0.4rem 0.8rem;
      height: 2rem;
    }

    /* Mobile responsiveness for config editor */
    @media (max-width: 768px) {
      .config-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .config-controls .btn {
        min-width: auto;
        width: 100%;
      }

      .config-info {
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }

      .config-editor {
        min-height: 300px;
        font-size: 0.85rem;
      }

      .backup-modal-content {
        width: 95%;
        margin: 10% auto;
        padding: 1rem;
      }

      .backup-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .backup-actions {
        width: 100%;
        justify-content: flex-end;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="tab-bar">
      <button class="tab active" id="tab-processes" onclick="showTab('processes')">ðŸš€ Processes</button>
      <button class="tab" id="tab-statistics" onclick="showTab('statistics')">ðŸ“Š Statistics</button>
      <button class="tab" id="tab-certificates" onclick="showTab('certificates')">ðŸ”’ Certificates</button>
      <button class="tab" id="tab-cache" onclick="showTab('cache')">ðŸ’¾ Cache</button>
      <button class="tab" id="tab-config" onclick="showTab('config')">âš™ï¸ Configuration</button>
    </div>

    <!-- Processes Tab -->
    <div id="content-processes" class="tab-content active">
      <div class="header">
        <div class="header-content">
          <div class="header-left">
            <h1>âš™ï¸ Process Management</h1>
            <p>Monitor and control managed processes</p>
          </div>
          <div class="header-right">
            <div class="last-updated-info">
              <span class="last-updated-label">Last Updated:</span>
              <span class="last-updated-time" id="header-last-updated">-</span>
            </div>
          </div>
        </div>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>Total Processes</h4>
          <div class="value" id="processes-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Running</h4>
          <div class="value" id="running-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Stopped</h4>
          <div class="value" id="stopped-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Uptime</h4>
          <div class="value" id="uptime">-</div>
        </div>
      </div>

      <div class="process-tabs" id="process-tabs">
        <div class="process-tabs-header process-tab-scroll" id="process-tabs-header">
          <!-- Process tabs will be generated here -->
        </div>
        <div id="process-tabs-content">
          <!-- Process tab content will be generated here -->
        </div>
      </div>
    </div>

    <!-- Statistics Tab -->
    <div id="content-statistics" class="tab-content">
      <div class="header">
        <h1>ðŸ“Š HTTP Service Statistics</h1>
        <p>Monitor proxy traffic, routes, and geolocation data</p>
      </div>

      <!-- World map heatmap for geolocation statistics -->
      <div id="geo-heatmap" style="width:100%;height:500px;"></div>

      <div class="time-filter">
        <h3>Time Period</h3>
        <div class="filter-buttons">
          <button class="filter-btn active" onclick="setTimeFilter('1h')">1 Hour</button>
          <button class="filter-btn" onclick="setTimeFilter('24h')">24 Hours</button>
          <button class="filter-btn" onclick="setTimeFilter('7d')">7 Days</button>
          <button class="filter-btn" onclick="setTimeFilter('30d')">30 Days</button>
        </div>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>Total Requests</h4>
          <div class="value" id="totalRequests">-</div>
        </div>
        <div class="stat-card">
          <h4>Unique IPs</h4>
          <div class="value" id="uniqueIPs">-</div>
        </div>
        <div class="stat-card">
          <h4>Active Routes</h4>
          <div class="value" id="activeRoutes">-</div>
        </div>
        <div class="stat-card">
          <h4>Countries</h4>
          <div class="value" id="uniqueCountries">-</div>
        </div>
        <div class="stat-card">
          <h4>Avg Response Time</h4>
          <div class="value" id="avgResponseTime">-</div>
        </div>
      </div>

      <div class="routes-section">
        <h2>Route Statistics</h2>
        <div style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
          <button id="clear-statistics-btn" class="btn btn-stop" style="margin-left: auto;">ðŸ—‘ï¸ Clear
            Statistics</button>
        </div>
        <div id="time-period" class="time-period-display">Loading time period...</div>
        <div id="routes-container">
          <div class="loading">Loading route statistics...</div>
        </div>
      </div>

      <script>
        document.getElementById('clear-statistics-btn').onclick = async function () {
          if (!confirm('Are you sure you want to clear all HTTP statistics? This cannot be undone.')) return;
          this.disabled = true;
          this.textContent = 'Clearing...';
          try {
            const res = await fetch('/api/statistics/clear', { method: 'POST' });
            const data = await res.json();
            if (data.success) {
              alert('Statistics cleared!');
              loadStatistics();
            } else {
              alert('Failed to clear statistics: ' + (data.error || 'Unknown error'));
            }
          } catch (err) {
            alert('Failed to clear statistics: ' + err);
          }
          this.disabled = false;
          this.textContent = 'ðŸ—‘ï¸ Clear Statistics';
        };
      </script>
    </div>

    <!-- Certificates Tab -->
    <div id="content-certificates" class="tab-content">
      <div class="header">
        <h1>ðŸ”’ SSL Certificates</h1>
        <p>Manage SSL certificates and Let's Encrypt configuration</p>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>SSL Certificates</h4>
          <div class="value" id="certificates-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Valid Certificates</h4>
          <div class="value" id="valid-certificates">-</div>
        </div>
        <div class="stat-card">
          <h4>Expiring Soon</h4>
          <div class="value" id="expiring-soon">-</div>
        </div>
        <div class="stat-card">
          <h4>Expired</h4>
          <div class="value" id="expired-certificates">-</div>
        </div>
        <div class="stat-card">
          <h4>Let's Encrypt</h4>
          <div class="value" id="letsencrypt-status">-</div>
        </div>
      </div>

      <div class="certificates-section">
        <h2>SSL Certificates</h2>
        <p class="section-description">Let's Encrypt certificate status and expiration information</p>
        <button onclick="loadCertificates()" class="refresh-btn">ðŸ”„ Refresh Certificates</button>
        <div id="certificates-container">
          <div class="loading">Loading certificates...</div>
        </div>
      </div>
    </div>

    <!-- Cache Tab -->
    <div id="content-cache" class="tab-content">
      <div class="header">
        <h1>ðŸ’¾ Response Cache Management</h1>
        <p>Monitor and manage disk-based cache with in-memory MRU (100 items)</p>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>Total Entries</h4>
          <div class="value" id="cache-total-entries">-</div>
        </div>
        <div class="stat-card">
          <h4>MRU Entries</h4>
          <div class="value" id="cache-mru-entries">-</div>
        </div>
        <div class="stat-card">
          <h4>Total Size</h4>
          <div class="value" id="cache-total-size">-</div>
        </div>
        <div class="stat-card">
          <h4>Active Users</h4>
          <div class="value" id="cache-active-users">-</div>
        </div>
        <div class="stat-card">
          <h4>Cache Hit Rate</h4>
          <div class="value" id="cache-hit-rate">-</div>
        </div>
      </div>

      <div class="cache-controls">
        <button onclick="loadCacheStats()" class="refresh-btn">ðŸ”„ Refresh Stats</button>
        <button onclick="clearAllCache()" class="btn btn-stop">ðŸ—‘ï¸ Clear All Cache</button>
        <button onclick="cleanupExpiredCache()" class="btn btn-restart">ðŸ§¹ Cleanup Expired</button>
      </div>

      <div class="cache-tabs">
        <div class="cache-tabs-header">
          <button class="cache-tab active" id="cache-tab-overview" onclick="switchCacheTab('overview')">ðŸ“Š
            Overview</button>
          <button class="cache-tab" id="cache-tab-users" onclick="switchCacheTab('users')">ðŸ‘¥ Users</button>
          <button class="cache-tab" id="cache-tab-entries" onclick="switchCacheTab('entries')">ðŸ“‹ Entries</button>
        </div>

        <!-- Cache Overview Tab -->
        <div id="cache-content-overview" class="cache-tab-content active">
          <div class="cache-section">
            <h2>Cache Statistics</h2>
            <div id="cache-stats-container">
              <div class="loading">Loading cache statistics...</div>
            </div>
          </div>
        </div>

        <!-- Cache Users Tab -->
        <div id="cache-content-users" class="cache-tab-content">
          <div class="cache-section">
            <h2>Cache Users</h2>
            <p class="section-description">Users with cached entries and their activity</p>
            <div id="cache-users-container">
              <div class="loading">Loading cache users...</div>
            </div>
          </div>
        </div>

        <!-- Cache Entries Tab -->
        <div id="cache-content-entries" class="cache-tab-content">
          <div class="cache-section">
            <h2>Cache Entries</h2>
            <p class="section-description">Detailed view of all cache entries with filtering</p>

            <div class="cache-filters">
              <div class="filter-group">
                <label for="cache-user-filter">User:</label>
                <select id="cache-user-filter" onchange="filterCacheEntries()">
                  <option value="">All Users</option>
                </select>
              </div>
              <div class="filter-group">
                <label for="cache-mru-filter">Location:</label>
                <select id="cache-mru-filter" onchange="filterCacheEntries()">
                  <option value="">All</option>
                  <option value="true">MRU Only</option>
                  <option value="false">Disk Only</option>
                </select>
              </div>
              <div class="filter-group">
                <label for="cache-entries-limit">Limit:</label>
                <select id="cache-entries-limit" onchange="loadCacheEntries()">
                  <option value="25">25</option>
                  <option value="50" selected>50</option>
                  <option value="100">100</option>
                  <option value="200">200</option>
                </select>
              </div>
            </div>

            <div class="cache-pagination">
              <button id="cache-prev-page" onclick="changeCachePage(-1)" class="btn" disabled>â† Previous</button>
              <span id="cache-page-info">Page 1</span>
              <button id="cache-next-page" onclick="changeCachePage(1)" class="btn">Next â†’</button>
            </div>

            <div id="cache-entries-container">
              <div class="loading">Loading cache entries...</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Configuration Editor Tab -->
  <div id="content-config" class="tab-content">
    <div class="header">
      <h1>âš™ï¸ Configuration Editor</h1>
      <p>Edit proxy routes and process configurations with automatic backup</p>
    </div>

    <div class="config-tabs">
      <div class="config-tabs-header">
        <button class="config-tab active" id="config-tab-proxy" onclick="switchConfigTab('proxy')">ðŸŒ Proxy
          Routes</button>
        <button class="config-tab" id="config-tab-processes" onclick="switchConfigTab('processes')">ðŸš€
          Processes</button>
      </div>

      <!-- Proxy Configuration Tab -->
      <div id="config-content-proxy" class="config-tab-content active">
        <div class="config-section">
          <h2>Proxy Configuration</h2>
          <p class="section-description">Edit the main proxy configuration file (config/main.yaml)</p>

          <div class="config-controls">
            <button onclick="loadConfig('proxy')" class="refresh-btn">ðŸ”„ Load Config</button>
            <button onclick="backupConfig('proxy')" class="btn btn-restart">ðŸ’¾ Create Backup</button>
            <button onclick="saveConfig('proxy')" class="btn btn-start">ðŸ’¾ Save Changes</button>
            <button onclick="showBackups('proxy')" class="btn btn-logs">ðŸ“‹ View Backups</button>
          </div>

          <div class="config-info">
            <div class="config-info-item">
              <label>File Path:</label>
              <span id="proxy-config-path">-</span>
            </div>
            <div class="config-info-item">
              <label>Last Modified:</label>
              <span id="proxy-config-modified">-</span>
            </div>
          </div>

          <div class="config-editor-container">
            <textarea id="proxy-config-editor" class="config-editor" placeholder="Loading configuration..."></textarea>
          </div>

          <div class="config-validation">
            <div id="proxy-config-validation" class="validation-message"></div>
          </div>
        </div>
      </div>

      <!-- Processes Configuration Tab -->
      <div id="config-content-processes" class="config-tab-content">
        <div class="config-section">
          <h2>Process Configuration</h2>
          <p class="section-description">Edit the process management configuration file (config/processes.yaml)</p>

          <div class="config-controls">
            <button onclick="loadConfig('processes')" class="refresh-btn">ðŸ”„ Load Config</button>
            <button onclick="backupConfig('processes')" class="btn btn-restart">ðŸ’¾ Create Backup</button>
            <button onclick="saveConfig('processes')" class="btn btn-start">ðŸ’¾ Save Changes</button>
            <button onclick="showBackups('processes')" class="btn btn-logs">ðŸ“‹ View Backups</button>
          </div>

          <div class="config-info">
            <div class="config-info-item">
              <label>File Path:</label>
              <span id="processes-config-path">-</span>
            </div>
            <div class="config-info-item">
              <label>Last Modified:</label>
              <span id="processes-config-modified">-</span>
            </div>
          </div>

          <div class="config-editor-container">
            <textarea id="processes-config-editor" class="config-editor"
              placeholder="Loading configuration..."></textarea>
          </div>

          <div class="config-validation">
            <div id="processes-config-validation" class="validation-message"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Backup Modal -->
  <div id="backup-modal" class="backup-modal">
    <div class="backup-modal-content">
      <div class="backup-modal-header">
        <h3 class="backup-modal-title">Configuration Backups</h3>
        <button class="backup-modal-close" onclick="closeBackupModal()">&times;</button>
      </div>
      <div id="backup-list" class="backup-list">
        <div class="loading">Loading backups...</div>
      </div>
    </div>
  </div>

  <script src="config-editor.js"></script>
  <script>
    // Utility function to format timestamps in local time
    function formatLocalTime(timestamp) {
      if (!timestamp) return 'N/A';

      try {
        const date = new Date(timestamp);
        if (isNaN(date.getTime())) return 'Invalid Date';

        // Format the date in local region format
        const localDate = date.toLocaleString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });

        // Calculate elapsed time
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);

        let elapsedText = '';
        if (diffDays > 0) {
          elapsedText = ` (${diffDays} day${diffDays > 1 ? 's' : ''} ago)`;
        } else if (diffHours > 0) {
          elapsedText = ` (${diffHours} hour${diffHours > 1 ? 's' : ''} ago)`;
        } else if (diffMinutes > 0) {
          elapsedText = ` (${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago)`;
        } else {
          elapsedText = ' (just now)';
        }

        return `${localDate}${elapsedText}`;
      } catch (error) {
        return 'Invalid Date';
      }
    }

    // Utility function to format relative time (e.g., "2 hours ago")
    function formatRelativeTime(timestamp) {
      if (!timestamp) return 'N/A';

      try {
        const date = new Date(timestamp);
        if (isNaN(date.getTime())) return 'Invalid Date';

        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);

        if (diffDays > 0) {
          return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        } else if (diffHours > 0) {
          return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        } else if (diffMinutes > 0) {
          return `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago`;
        } else {
          return 'Just now';
        }
      } catch (error) {
        return 'Invalid Date';
      }
    }

    // Global variables
    let ws = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    const reconnectDelay = 2000;
    let processesData = [];
    let statusData = {};
    let liveUpdateIntervals = {};
    let currentTimeFilter = '24h';
    let geoHeatmapChart = null;
    let geoHeatmapLoaded = false;
    let certificatesData = {};
    let currentLogLines = 100;
    let logUpdateIntervals = {};
    let activeProcessTab = null;
    let currentLogFilter = 'all'; // 'all', 'stdout', 'stderr'
    let processLogs = {}; // Store logs for each process with stream info
    let showLogsSinceRestart = false; // Track if we should show logs since last restart
    let processLastRestartTimes = {}; // Store last restart times for each process
    let isAtBottom = true; // Track if user is at bottom of logs for auto-follow

    // Cache management variables
    let cacheData = {};
    let cacheUsers = [];
    let cacheEntries = [];
    let currentCachePage = 1;
    let cacheEntriesPerPage = 50;
    let activeCacheTab = 'overview';
    let cacheFilters = {
      user: '',
      mru: ''
    };

    // Tab switching logic
    function showTab(tab, pushState = true) {
      // Hide all tabs
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      // Show selected tab
      document.getElementById(`tab-${tab}`).classList.add('active');
      document.getElementById(`content-${tab}`).classList.add('active');

      // Load data for specific tabs
      if (tab === 'statistics') {
        if (!geoHeatmapLoaded) {
          renderGeoHeatmap();
        }
        loadStatistics();
      } else if (tab === 'certificates') {
        loadCertificates();
      } else if (tab === 'cache') {
        loadCacheStats();
      } else if (tab === 'config') {
        // Load configuration when config tab is selected
        if (typeof loadConfig === 'function' && typeof currentConfigType !== 'undefined') {
          loadConfig(currentConfigType);
        }
      }

      // Update history state
      if (pushState) {
        const state = { tab, process: activeProcessTab };
        const url = `#${tab}` + (activeProcessTab ? `-${activeProcessTab}` : '');
        window.history.pushState(state, '', url);
      }
    }

    function switchProcessTab(processId, pushState = true) {
      // Remove active class from all tabs
      document.querySelectorAll('.process-tab').forEach(tab => {
        tab.classList.remove('active');
      });

      // Hide all tab content
      document.querySelectorAll('.process-tab-content').forEach(content => {
        content.classList.remove('active');
      });

      // Activate the selected tab
      const selectedTab = document.querySelector(`[data-process-id="${processId}"]`);
      if (selectedTab) {
        selectedTab.classList.add('active');
      }

      // Show the corresponding content
      const selectedContent = document.getElementById(`process-content-${processId}`);
      if (selectedContent) {
        selectedContent.classList.add('active');
      }

      // Update active process tab
      activeProcessTab = processId;

      // Reset "since restart" state when switching tabs
      showLogsSinceRestart = false;

      // Request logs for the active tab
      requestLogs(processId, currentLogLines);

      // Set up live updates for this process
      setupLiveUpdates(processId);

      // Update history state
      if (pushState) {
        // Find the currently active main tab
        const activeTab = document.querySelector('.tab.active');
        const tab = activeTab ? activeTab.id.replace('tab-', '') : 'processes';
        const state = { tab, process: processId };
        const url = `#${tab}-${processId}`;
        window.history.pushState(state, '', url);
      }
    }

    // Handle browser navigation (back/forward)
    window.addEventListener('popstate', (event) => {
      const state = event.state;
      if (state) {
        // Restore tab
        showTab(state.tab || 'processes', false);
        // Restore process tab if present
        if (state.tab === 'processes' && state.process) {
          switchProcessTab(state.process, false);
        }
      } else {
        // Default to processes tab
        showTab('processes', false);
      }
    });

    // On page load, restore state from URL hash or default
    window.addEventListener('DOMContentLoaded', () => {
      let tab = 'processes';
      let process = null;
      if (window.location.hash) {
        const hash = window.location.hash.replace('#', '');
        const parts = hash.split('-');
        if (parts.length > 0) tab = parts[0];
        if (parts.length > 1) process = parts.slice(1).join('-');
      }
      showTab(tab, false);
      if (tab === 'processes' && process) {
        // Wait for processesData to be loaded, then switch
        const trySwitch = () => {
          const processes = Array.isArray(processesData) ? processesData : [];
          if (processes.length > 0 && processes.find(p => p && p.id === process)) {
            switchProcessTab(process, false);
          } else {
            setTimeout(trySwitch, 100);
          }
        };
        trySwitch();
      }

      // Start periodic uptime updates
      startUptimeUpdates();

      // Start periodic process uptime updates
      startProcessUptimeUpdates();
    });

    // WebSocket connection management
    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws`;

      ws = new WebSocket(wsUrl);

      ws.onopen = function () {
        console.log('WebSocket connected');
        reconnectAttempts = 0;
        updateConnectionStatus(true);
      };

      ws.onmessage = function (event) {
        try {
          const message = JSON.parse(event.data);
          handleWebSocketMessage(message);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };

      ws.onclose = function () {
        console.log('WebSocket disconnected');
        updateConnectionStatus(false);

        // Attempt to reconnect
        if (reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
          setTimeout(connectWebSocket, reconnectDelay);
        } else {
          console.error('Max reconnection attempts reached');
          showNotification('WebSocket connection lost. Please refresh the page.', 'error');
        }
      };

      ws.onerror = function (error) {
        console.error('WebSocket error:', error);
      };
    }

    function updateConnectionStatus(connected) {
      const statusElement = document.getElementById('connection-status');
      if (statusElement) {
        statusElement.textContent = connected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected';
        statusElement.className = connected ? 'connected' : 'disconnected';
      }
    }

    function handleWebSocketMessage(message) {
      switch (message.type) {
        case 'processes':
          const oldProcessesData = processesData;
          processesData = Array.isArray(message.data) ? message.data : [];

          // If this is the first load, update the entire display
          if (!oldProcessesData || oldProcessesData.length === 0) {
            updateProcessesDisplay();
          } else {
            // Update individual process information without regenerating HTML
            processesData.forEach(process => {
              if (process && process.id) {
                updateProcessInfo(process.id, process);
              }
            });
          }
          break;
        case 'status':
          statusData = message.data || {};
          updateStatusDisplay();
          break;
        case 'logs':
          updateProcessLogs(message.data.processId, message.data.logs);
          break;
        case 'error':
          console.error('WebSocket error:', message.data);
          showNotification('WebSocket error: ' + message.data.message, 'error');
          break;
        case 'pong':
          // Handle ping/pong for connection health
          break;
        default:
          console.warn('Unknown WebSocket message type:', message.type);
      }
    }

    function requestLogs(processId, lines = currentLogLines) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'request_logs',
          processId: processId,
          lines: lines
        }));
      }
    }

    function setLogLines(lines) {
      if (lines === 'all') {
        currentLogLines = 'all';
      } else {
        currentLogLines = parseInt(lines);
      }
      // Update active process tab with new line count
      if (activeProcessTab) {
        requestLogs(activeProcessTab, currentLogLines);
      }
    }

    function setLogFilter(filter) {
      currentLogFilter = filter;
      // Update active process tab with new filter
      if (activeProcessTab && processLogs[activeProcessTab]) {
        updateProcessLogsDisplay(activeProcessTab, processLogs[activeProcessTab]);
      }
    }

    function setLogsSinceRestart(enabled) {
      showLogsSinceRestart = enabled;
      // Update active process tab with new setting
      if (activeProcessTab && processLogs[activeProcessTab]) {
        updateProcessLogsDisplay(activeProcessTab, processLogs[activeProcessTab]);
      }
    }

    // Helper function to normalize process status
    function getProcessStatus(process) {
      // Backend sends isRunning: true/false, frontend expects 'running'/'stopped'
      if (process.isRunning === true) return 'running';
      if (process.isRunning === false) return 'stopped';
      // Fallback to status field if isRunning is not available
      return process.status || 'stopped';
    }

    // Update status display
    function updateStatusDisplay() {
      // Ensure processes is an array and handle potential undefined/null values
      const processes = Array.isArray(statusData.processes) ? statusData.processes : [];
      const processesCount = processes.length;
      const runningCount = processes.filter(p => p && getProcessStatus(p) === 'running').length;
      const stoppedCount = processesCount - runningCount;
      const uptime = statusData.uptime || 0;
      const timestamp = statusData.timestamp ? formatLocalTime(statusData.timestamp) : 'N/A';

      document.getElementById('processes-count').textContent = processesCount;
      document.getElementById('running-count').textContent = runningCount;
      document.getElementById('stopped-count').textContent = stoppedCount;
      document.getElementById('uptime').textContent = formatUptime(uptime * 1000);

      // Update the header last updated time
      const headerLastUpdated = document.getElementById('header-last-updated');
      if (headerLastUpdated) {
        headerLastUpdated.textContent = timestamp;
      }

      // Store the uptime start time for periodic updates
      if (statusData.timestamp) {
        window.serverStartTime = new Date(statusData.timestamp).getTime() - (uptime * 1000);
      }
    }

    // Periodic uptime update function
    function updateUptimePeriodically() {
      if (window.serverStartTime) {
        const currentUptime = Date.now() - window.serverStartTime;
        const uptimeElement = document.getElementById('uptime');
        if (uptimeElement) {
          uptimeElement.textContent = formatUptime(currentUptime);
        }
      }
    }

    // Start periodic uptime updates
    function startUptimeUpdates() {
      // Update uptime every second
      setInterval(updateUptimePeriodically, 1000);
    }

    // Update process information fields without regenerating entire HTML
    function updateProcessInfo(processId, processData) {
      const processContent = document.getElementById(`process-content-${processId}`);
      if (!processContent) return;

      const status = getProcessStatus(processData);

      // Update status
      const statusElement = processContent.querySelector('.process-tab-info-item:first-child .process-tab-info-value');
      if (statusElement) {
        const statusClass = status === 'running' ? 'success' : 'error';
        const statusText = status === 'running' ? 'Running' : 'Stopped';
        statusElement.className = `process-tab-info-value ${statusClass}`;
        statusElement.textContent = statusText;
      }

      // Update PID
      const pidElement = processContent.querySelector('.process-tab-info-item:nth-child(2) .process-tab-info-value');
      if (pidElement) {
        pidElement.textContent = processData.pid || 'N/A';
      }

      // Update uptime
      const uptimeElement = processContent.querySelector('.process-tab-info-item:nth-child(3) .process-tab-info-value');
      if (uptimeElement) {
        uptimeElement.textContent = processData.uptime ? formatUptime(processData.uptime) : 'N/A';
      }

      // Update restart count
      const restartElement = processContent.querySelector('.process-tab-section .process-tab-info-item:nth-child(1) .process-tab-info-value');
      if (restartElement) {
        restartElement.className = `process-tab-info-value ${getRestartCountClass(processData.restartAttempts || 0)}`;
        restartElement.textContent = processData.restartAttempts || 0;
      }

      // Update health failures
      const healthElement = processContent.querySelector('.process-tab-section .process-tab-info-item:nth-child(2) .process-tab-info-value');
      if (healthElement) {
        healthElement.className = `process-tab-info-value ${getRestartCountClass(processData.healthFailures || 0)}`;
        healthElement.textContent = processData.healthFailures || 0;
      }

      // Update last health check time
      const lastHealthCheckElement = processContent.querySelector('.process-tab-section .process-tab-info-item:nth-child(3) .process-tab-info-value');
      if (lastHealthCheckElement) {
        lastHealthCheckElement.textContent = processData.lastHealthCheckTime ? formatLocalTime(processData.lastHealthCheckTime) : 'N/A';
      }

      // Update start time
      const startTimeElement = processContent.querySelector('.process-tab-section .process-tab-info-item:nth-child(4) .process-tab-info-value');
      if (startTimeElement) {
        startTimeElement.textContent = processData.startTime ? formatLocalTime(processData.startTime) : 'N/A';
      }

      // Update last restart time
      const lastRestartElement = processContent.querySelector('.process-tab-section .process-tab-info-item:nth-child(5) .process-tab-info-value');
      if (lastRestartElement) {
        lastRestartElement.textContent = processData.lastRestartTime ? formatLocalTime(processData.lastRestartTime) : 'N/A';
      }

      // Update tab header status indicator
      const tabButton = document.querySelector(`[data-process-id="${processId}"]`);
      if (tabButton) {
        const statusIndicator = tabButton.querySelector('.process-tab-status');
        if (statusIndicator) {
          statusIndicator.className = `process-tab-status ${status === 'running' ? 'running' : 'stopped'}`;
        }
      }

      // Update action buttons
      const startButton = processContent.querySelector('.btn-start');
      const stopButton = processContent.querySelector('.btn-stop');

      if (startButton) {
        startButton.disabled = status === 'running';
      }
      if (stopButton) {
        stopButton.disabled = status !== 'running';
      }
    }

    // Update processes display
    function updateProcessesDisplay() {
      const tabsHeader = document.getElementById('process-tabs-header');
      const tabsContent = document.getElementById('process-tabs-content');

      // Ensure processesData is an array
      const processes = Array.isArray(processesData) ? processesData : [];

      if (processes.length === 0) {
        tabsHeader.innerHTML = '';
        tabsContent.innerHTML = `
          <div class="no-processes-tab">
            <h3>No Processes Configured</h3>
            <p>No processes are currently configured or available.</p>
          </div>
        `;
        return;
      }

      // Preserve current active tab
      const currentActiveTab = activeProcessTab || (processes.length > 0 ? processes[0].id : null);

      // Generate tab headers
      const tabHeaders = processes.map((process) => {
        const statusClass = getProcessStatus(process) === 'running' ? 'running' : 'stopped';
        const isActive = process.id === currentActiveTab ? 'active' : '';

        return `
          <button class="process-tab ${isActive}" data-process-id="${process.id}" onclick="switchProcessTab('${process.id}')">
            <div class="process-tab-status ${statusClass}"></div>
            <span>${process.name || process.id}</span>
          </button>
        `;
      }).join('');

      // Generate tab content
      const tabContents = processes.map((process) => {
        const isActive = process.id === currentActiveTab ? 'active' : '';
        const status = getProcessStatus(process);
        const statusClass = status === 'running' ? 'success' : 'error';
        const statusText = status === 'running' ? 'Running' : 'Stopped';

        return `
          <div class="process-tab-content ${isActive}" id="process-content-${process.id}">
            <div class="process-tab-header">
              <div class="process-tab-actions">
                <button onclick="startProcess('${process.id}')" class="btn btn-start" ${status === 'running' ? 'disabled' : ''}>
                  Start
                </button>
                <button onclick="stopProcess('${process.id}')" class="btn btn-stop" ${status !== 'running' ? 'disabled' : ''}>
                  Stop
                </button>
                <button onclick="restartProcess('${process.id}')" class="btn btn-restart">
                  Restart
                </button>
              </div>
              <div class="process-tab-info">
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Status</span>
                  <span class="process-tab-info-value ${statusClass}">${statusText}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">PID</span>
                  <span class="process-tab-info-value">${process.pid || 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Uptime</span>
                  <span class="process-tab-info-value">${process.uptime ? formatUptime(process.uptime) : 'N/A'}</span>
                </div>
                <button class="btn btn-xs" onclick="toggleDetails('${process.id}')">Details</button>
              </div>
            </div>
            <div class="process-tab-section collapsible" id="details-${process.id}">
              <div class="process-tab-info">
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Restart Count</span>
                  <span class="process-tab-info-value ${getRestartCountClass(process.restartAttempts || 0)}">${process.restartAttempts || 0}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Health Failures</span>
                  <span class="process-tab-info-value ${getRestartCountClass(process.healthFailures || 0)}">${process.healthFailures || 0}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Last Health Check</span>
                  <span class="process-tab-info-value time-display">${process.lastHealthCheckTime ? formatLocalTime(process.lastHealthCheckTime) : 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Start Time</span>
                  <span class="process-tab-info-value time-display">${process.startTime ? formatLocalTime(process.startTime) : 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Last Restart</span>
                  <span class="process-tab-info-value time-display">${process.lastRestartTime ? formatLocalTime(process.lastRestartTime) : 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Log File</span>
                  <span class="process-tab-info-value" style="font-size: 0.8rem;">${process.logFile || 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">PID File</span>
                  <span class="process-tab-info-value" style="font-size: 0.8rem;">${process.pidFile || 'N/A'}</span>
                </div>
              </div>
            </div>
            <div class="process-tab-section">
              <h3>ðŸ“‹ Process Logs</h3>
              <div class="logs-container" id="logs-${process.id}">
                <div class="logs-header">
                  <div class="logs-title">Process Logs</div>
                  <div class="logs-controls">
                    <select onchange="setLogLines(this.value)" title="Number of log lines to display">
                      <option value="100">100 lines</option>
                      <option value="500">500 lines</option>
                      <option value="1000">1,000 lines</option>
                      <option value="5000">5,000 lines</option>
                      <option value="10000">10,000 lines</option>
                      <option value="all">All logs</option>
                    </select>
                    <div class="logs-filter-buttons">
                      <button class="logs-filter-btn all active" onclick="setLogFilter('all')" title="Show all logs">All</button>
                      <button class="logs-filter-btn stdout" onclick="setLogFilter('stdout')" title="Show stdout only">STDOUT</button>
                      <button class="logs-filter-btn stderr" onclick="setLogFilter('stderr')" title="Show stderr only">STDERR</button>
                      <button class="logs-filter-btn logs-since-restart" onclick="setLogsSinceRestart(!showLogsSinceRestart)" title="Show logs since last restart">Since Restart</button>
                    </div>
                    <button class="follow-btn active" onclick="scrollToBottom('${process.id}')" title="Follow logs (scroll to bottom)">
                      <span>ðŸ“‹</span>
                      <span>Follow</span>
                    </button>
                    <div class="live-indicator following">
                      <div class="live-dot"></div>
                      <span>Live</span>
                    </div>
                  </div>
                </div>
                <div class="logs-loading">Click tab to load recent log entries</div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      tabsHeader.innerHTML = tabHeaders;
      tabsContent.innerHTML = tabContents;

      // Update active process tab if it changed
      if (currentActiveTab && currentActiveTab !== activeProcessTab) {
        activeProcessTab = currentActiveTab;
        // Request logs for the active tab if it's the first time
        if (!processLogs[currentActiveTab]) {
          requestLogs(currentActiveTab, currentLogLines);
          setupLiveUpdates(currentActiveTab);
        }
      } else if (!activeProcessTab && processes.length > 0) {
        // Set the first process as active if no active tab
        switchProcessTab(processes[0].id);
      }
    }

    // Process control functions
    async function startProcess(processId) {
      await performProcessAction(processId, 'start');
    }

    async function stopProcess(processId) {
      await performProcessAction(processId, 'stop');
    }

    async function restartProcess(processId) {
      await performProcessAction(processId, 'restart');
    }

    async function performProcessAction(processId, action) {
      try {
        const response = await fetch(`/api/processes/${processId}/${action}`, {
          method: 'POST'
        });

        const data = await response.json();

        if (data.success) {
          showNotification(`Process ${processId} ${action}ed successfully`, 'success');
          // WebSocket will automatically update the display
        } else {
          showNotification(`Failed to ${action} process: ` + data.error, 'error');
        }
      } catch (error) {
        showNotification(`Failed to ${action} process: ` + error.message, 'error');
      }
    }

    // Update process logs via WebSocket
    function updateProcessLogs(processId, logs) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) {
        return;
      }

      // Store last restart time for this process
      const processes = Array.isArray(processesData) ? processesData : [];
      const process = processes.find(p => p && p.id === processId);
      if (process && process.lastRestartTime) {
        processLastRestartTimes[processId] = new Date(process.lastRestartTime).getTime();
      }

      if (!logs || logs.length === 0) {
        logsContainer.innerHTML = `
          <div class="logs-header">
            <div class="logs-title">Process Logs</div>
            <div class="logs-controls">
              <select onchange="setLogLines(this.value)" title="Number of log lines to display">
                <option value="100">100 lines</option>
                <option value="500">500 lines</option>
                <option value="1000">1,000 lines</option>
                <option value="5000">5,000 lines</option>
                <option value="10000">10,000 lines</option>
                <option value="all">All logs</option>
              </select>
              <div class="logs-filter-buttons">
                <button class="logs-filter-btn all active" onclick="setLogFilter('all')" title="Show all logs">All</button>
                <button class="logs-filter-btn stdout" onclick="setLogFilter('stdout')" title="Show stdout only">STDOUT</button>
                <button class="logs-filter-btn stderr" onclick="setLogFilter('stderr')" title="Show stderr only">STDERR</button>
                <button class="logs-filter-btn logs-since-restart" onclick="setLogsSinceRestart(!showLogsSinceRestart)" title="Show logs since last restart">Since Restart</button>
              </div>
              <button class="follow-btn active" onclick="scrollToBottom('${processId}')" title="Follow logs (scroll to bottom)">
                <span>ðŸ“‹</span>
                <span>Follow</span>
              </button>
              <div class="live-indicator following">
                <div class="live-dot"></div>
                <span>Live</span>
              </div>
            </div>
          </div>
          <div class="logs-loading">No logs available</div>
        `;
        return;
      }

      // Store logs with stream information
      const logsWithStreams = logs.map(log => {
        // Parse log line to determine stream type
        // Look for explicit stream prefixes first
        if (log.includes('[STDOUT]')) {
          return {
            content: log,
            stream: 'stdout'
          };
        }

        if (log.includes('[STDERR]')) {
          return {
            content: log,
            stream: 'stderr'
          };
        }

        // Fallback to pattern matching for logs without explicit prefixes
        const isStderr = log.includes('ERROR') ||
          log.includes('WARN') ||
          log.includes('FATAL') ||
          log.toLowerCase().includes('error') ||
          log.toLowerCase().includes('warning') ||
          log.toLowerCase().includes('fail') ||
          log.toLowerCase().includes('exception');

        return {
          content: log,
          stream: isStderr ? 'stderr' : 'stdout'
        };
      });

      // Store logs for this process
      processLogs[processId] = logsWithStreams;

      // Update display with current filter
      updateProcessLogsDisplay(processId, logsWithStreams);
    }

    // Update process logs display with filtering
    function updateProcessLogsDisplay(processId, logsWithStreams) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) {
        return;
      }

      // Filter logs based on current filter
      let filteredLogs = logsWithStreams.filter(log => {
        if (currentLogFilter === 'all') return true;
        return log.stream === currentLogFilter;
      });

      // Apply "since last restart" filter if enabled
      if (showLogsSinceRestart && processLastRestartTimes[processId]) {
        const lastRestartTime = processLastRestartTimes[processId];
        filteredLogs = filteredLogs.filter(log => {
          // Try to extract timestamp from log line
          const timestampMatch = log.content.match(/\[(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\]/);
          if (timestampMatch) {
            const logTime = new Date(timestampMatch[1]).getTime();
            return logTime >= lastRestartTime;
          }
          // If no timestamp found, include the log (better to show than hide)
          return true;
        });
      }

      // Update filter button states
      const filterButtons = logsContainer.querySelectorAll('.logs-filter-btn');
      filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent.toLowerCase() === currentLogFilter ||
          (currentLogFilter === 'all' && btn.textContent === 'All')) {
          btn.classList.add('active');
        }
        // Handle "Since Restart" button state
        if (btn.textContent === 'Since Restart') {
          if (showLogsSinceRestart) {
            btn.classList.add('active');
          }
        }
      });

      // Use DocumentFragment for better performance with large log volumes
      const fragment = document.createDocumentFragment();
      const logLinesContainer = document.createElement('div');
      logLinesContainer.className = 'logs-content';

      // Process logs in chunks to avoid blocking the UI
      const chunkSize = 1000;
      const processLogsInChunks = (startIndex) => {
        const endIndex = Math.min(startIndex + chunkSize, filteredLogs.length);

        for (let i = startIndex; i < endIndex; i++) {
          const logLine = document.createElement('div');
          logLine.className = `log-line ${filteredLogs[i].stream}`;
          logLine.innerHTML = filteredLogs[i].content;
          logLinesContainer.appendChild(logLine);
        }

        if (endIndex < filteredLogs.length) {
          // Process next chunk asynchronously
          setTimeout(() => processLogsInChunks(endIndex), 0);
        } else {
          // All chunks processed, update the container
          const header = logsContainer.querySelector('.logs-header');
          logsContainer.innerHTML = '';
          logsContainer.appendChild(header);
          logsContainer.appendChild(logLinesContainer);

          // Only scroll to bottom if user was at bottom before update
          if (isAtBottom) {
            logLinesContainer.scrollTop = logLinesContainer.scrollHeight;
          }

          // Setup scroll listener for this log container
          setupLogScrollListener(processId);
        }
      };

      // Update header with log count
      const header = logsContainer.querySelector('.logs-header');
      if (header) {
        const title = header.querySelector('.logs-title');
        if (title) {
          const totalLogs = logsWithStreams.length;
          const filteredCount = filteredLogs.length;
          let filterText = '';
          if (currentLogFilter !== 'all') {
            filterText += ` (${currentLogFilter.toUpperCase()})`;
          }
          if (showLogsSinceRestart) {
            filterText += ' (since restart)';
          }

          // Add indicator for "all logs" mode
          let lineCountText = '';
          if (currentLogLines === 'all') {
            lineCountText = ` (All ${filteredCount.toLocaleString()}/${totalLogs.toLocaleString()} lines)`;
          } else {
            lineCountText = ` (${filteredCount.toLocaleString()}/${totalLogs.toLocaleString()} lines)`;
          }

          title.textContent = `Process Logs${filterText}${lineCountText}`;
        }

        // Update follow button and live indicator
        const followBtn = header.querySelector('.follow-btn');
        const liveIndicator = header.querySelector('.live-indicator');

        if (followBtn) {
          if (isAtBottom) {
            followBtn.className = 'follow-btn active';
            followBtn.title = 'Following logs (scroll to bottom)';
            followBtn.innerHTML = '<span>ðŸ“‹</span><span>Follow</span>';
          } else {
            followBtn.className = 'follow-btn inactive';
            followBtn.title = 'Not following - click to follow logs';
            followBtn.innerHTML = '<span>â¸ï¸</span><span>Paused</span>';
          }
        }

        if (liveIndicator) {
          if (isAtBottom) {
            liveIndicator.className = 'live-indicator following';
            liveIndicator.innerHTML = '<div class="live-dot"></div><span>Live</span>';
          } else {
            liveIndicator.className = 'live-indicator not-following';
            liveIndicator.innerHTML = '<div class="live-dot"></div><span>Paused</span>';
          }
        }

        // Update dropdown selection
        const lineCountSelect = header.querySelector('select');
        if (lineCountSelect) {
          lineCountSelect.value = currentLogLines;
        }
      }

      // Start processing logs
      processLogsInChunks(0);

      // Show performance warning for very large log files
      if (currentLogLines === 'all' && filteredLogs.length > 50000) {
        setTimeout(() => {
          const warningDiv = document.createElement('div');
          warningDiv.className = 'logs-warning';
          warningDiv.innerHTML = `
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 4px; padding: 0.75rem; margin: 0.5rem 0; color: #92400e;">
              <strong>âš ï¸ Performance Notice:</strong> Displaying ${filteredLogs.length.toLocaleString()} log lines. 
              Large log files may impact browser performance. Consider using a smaller line count for better performance.
            </div>
          `;
          logsContainer.insertBefore(warningDiv, logsContainer.firstChild);
        }, 100);
      }
    }

    // Start live log updates for a process
    function setupLiveUpdates(processId) {
      // Stop live updates for other processes
      Object.keys(logUpdateIntervals).forEach(pid => {
        if (pid !== processId) {
          stopLiveLogUpdates(pid);
        }
      });

      // Start live updates for the current process
      startLiveLogUpdates(processId);
    }

    function startLiveLogUpdates(processId) {
      // Stop any existing interval for this process
      stopLiveLogUpdates(processId);

      // Request logs every 5 seconds via WebSocket
      logUpdateIntervals[processId] = setInterval(() => {
        requestLogs(processId, currentLogLines);
      }, 5000);
    }

    // Stop live log updates for a process
    function stopLiveLogUpdates(processId) {
      if (logUpdateIntervals[processId]) {
        clearInterval(logUpdateIntervals[processId]);
        delete logUpdateIntervals[processId];
      }
    }

    // Statistics functions
    function setTimeFilter(period) {
      currentTimeFilter = period;

      // Update active button
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      loadStatistics();
      if (geoHeatmapLoaded) {
        renderGeoHeatmap();
      }
    }

    async function loadStatistics() {
      try {
        const response = await fetch(`/api/statistics?period=${currentTimeFilter}`);
        const data = await response.json();

        if (data.success) {
          updateStatisticsDisplay(data.data);
        } else {
          console.error('Failed to load statistics:', data.error);
        }
      } catch (error) {
        console.error('Error loading statistics:', error);
      }
    }

    function updateStatisticsDisplay(data) {
      // Update overview cards using summary data
      const summary = data.summary || {};
      document.getElementById('totalRequests').textContent = formatNumber(summary.totalRequests || 0);
      document.getElementById('uniqueIPs').textContent = formatNumber(summary.uniqueIPs || 0);
      document.getElementById('uniqueCountries').textContent = formatNumber(summary.uniqueCountries || 0);

      // Handle average response time - could be in data.avgResponseTime or calculated from details
      let avgResponseTime = data.avgResponseTime || 0;
      if (!avgResponseTime && data.details && data.details.byIP && data.details.byIP.length > 0) {
        const totalResponseTimes = data.details.byIP.reduce((sum, ipStat) => {
          // If responseTimes is available in the data, use it
          if (ipStat.responseTimes && Array.isArray(ipStat.responseTimes)) {
            return sum + ipStat.responseTimes.reduce((ipSum, time) => ipSum + time, 0);
          }
          return sum;
        }, 0);
        const totalRequests = data.details.byIP.reduce((sum, ipStat) => sum + ipStat.count, 0);
        avgResponseTime = totalRequests > 0 ? totalResponseTimes / totalRequests : 0;
      }
      document.getElementById('avgResponseTime').textContent = avgResponseTime > 0 ? `${avgResponseTime.toFixed(2)}ms` : 'N/A';

      // Update route statistics
      const routesContainer = document.getElementById('routes-container');
      if (data.routes && Array.isArray(data.routes) && data.routes.length > 0) {
        // Group routes by name
        const groups = {};
        data.routes.forEach(route => {
          const groupName = route.name || 'Other';
          if (!groups[groupName]) groups[groupName] = [];
          groups[groupName].push(route);
        });

        // Add unmatched card at the end if present
        let unmatchedRoute = data.routes.find(r => r.name === 'Unmatched');
        if (unmatchedRoute) {
          groups['Unmatched'] = [unmatchedRoute];
        }

        const groupHtml = Object.entries(groups).map(([name, routes]) => {
          const cardsHtml = routes.map((route, routeIdx) => {
            const topCountriesHtml = route.topCountries && route.topCountries.length > 0
              ? route.topCountries.slice(0, 3).map(country =>
                `<span class="country-badge">${country.country} (${country.count})</span>`
              ).join('')
              : '<span class="no-data">No country data</span>';

            const methodsHtml = route.methods && route.methods.length > 0
              ? route.methods.map(method => `<span class="method-badge">${method}</span>`).join('')
              : '<span class="no-data">No method data</span>';

            // Expanded cities section (hidden by default)
            const allCitiesHtml = route.topCountries && route.topCountries.length > 0
              ? `<div class="route-cities-list" style="display:none; margin-top:1rem;">
                    <div style="font-weight:600; color:#4a5568; margin-bottom:0.5rem;">All Cities:</div>
                    <div style="display:flex; flex-wrap:wrap; gap:0.5rem;">
                      ${route.topCountries.map(country =>
                `<span class='country-badge'>${country.country}${country.city ? ` - ${country.city}` : ''} (${country.count})</span>`
              ).join('')}
                    </div>
                 </div>`
              : '';

            // Unmatched card: show unique paths on click
            let unmatchedPathsHtml = '';
            if (route.name === 'Unmatched' && route.uniquePaths && route.uniquePaths.length > 0) {
              unmatchedPathsHtml = `<div class="unmatched-paths-list" style="display:none; margin-top:1rem;">
                <div style="font-weight:600; color:#4a5568; margin-bottom:0.5rem;">Unique Paths Hit:</div>
                <div style="display:flex; flex-direction:column; gap:0.25rem; max-height:200px; overflow:auto;">
                  ${route.uniquePaths.map(p => `<span class='country-badge' style='background:#ddd;color:#333;'>${p}</span>`).join('')}
                </div>
              </div>`;
            }

            return `
              <div class="route-card${route.name === 'Unmatched' ? ' unmatched-card' : ''}" tabindex="0" style="cursor:pointer;" data-route-group="${name}" data-route-idx="${routeIdx}">
                <div class="route-header">
                  <div class="route-info">
                    <div class="route-domain">${route.domain || 'Unknown'}</div>
                    <div class="route-target">${route.target || 'Unknown'}</div>
                  </div>
                  <div class="route-stats">
                    <div class="route-requests">${formatNumber(route.requests)} requests</div>
                    <div class="route-response-time">${route.avgResponseTime > 0 ? route.avgResponseTime.toFixed(2) + 'ms' : 'N/A'}</div>
                  </div>
                </div>
                <div class="route-details">
                  <div class="route-detail">
                    <div class="route-detail-label">Top Countries:</div>
                    <div class="route-detail-value">${topCountriesHtml}</div>
                  </div>
                  <div class="route-detail">
                    <div class="route-detail-label">Methods:</div>
                    <div class="route-detail-value">${methodsHtml}</div>
                  </div>
                  <div class="route-detail">
                    <div class="route-detail-label">Unique IPs:</div>
                    <div class="route-detail-value">${route.uniqueIPs || 0}</div>
                  </div>
                </div>
                ${allCitiesHtml}
                ${unmatchedPathsHtml}
              </div>
            `;
          }).join('');
          return `
            <div class="route-group">
              <h3 class="route-group-title">${name}</h3>
              <div class="route-group-cards">${cardsHtml}</div>
            </div>
          `;
        }).join('');

        routesContainer.innerHTML = groupHtml;

        // Add expand/collapse click handler for each route card
        routesContainer.querySelectorAll('.route-card').forEach(card => {
          card.addEventListener('click', function (e) {
            const citiesList = this.querySelector('.route-cities-list');
            if (citiesList) {
              const isVisible = citiesList.style.display === 'block';
              citiesList.style.display = isVisible ? 'none' : 'block';
              this.classList.toggle('expanded', !isVisible);
            }
            // For unmatched card, toggle unique paths
            const unmatchedPathsList = this.querySelector('.unmatched-paths-list');
            if (unmatchedPathsList) {
              const isVisible = unmatchedPathsList.style.display === 'block';
              unmatchedPathsList.style.display = isVisible ? 'none' : 'block';
              this.classList.toggle('expanded', !isVisible);
            }
          });
        });
      } else {
        routesContainer.innerHTML = '<div class="no-data">No route statistics available for the selected time period</div>';
      }

      // Update time period display
      if (data.period) {
        const startDate = new Date(data.period.start).toLocaleString();
        const endDate = new Date(data.period.end).toLocaleString();
        document.getElementById('time-period').textContent = `${startDate} - ${endDate}`;
      }
    }

    async function renderGeoHeatmap() {
      const container = document.getElementById('geo-heatmap');
      container.innerHTML = '';

      if (!window.echarts) {
        container.innerHTML = '<div style="color:#e53e3e;padding:2rem;text-align:center;">ECharts library not loaded</div>';
        return;
      }

      // Dynamically load and register world geoJSON if not already registered
      if (!echarts.getMap('world')) {
        try {
          const res = await fetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson');
          const geoJson = await res.json();
          echarts.registerMap('world', geoJson);
        } catch (err) {
          container.innerHTML = '<div style="color:#e53e3e;padding:2rem;text-align:center;">Failed to load world map data</div>';
          return;
        }
      }

      if (!geoHeatmapChart) {
        geoHeatmapChart = echarts.init(container);
      }

      geoHeatmapChart.showLoading('default', { text: 'Loading geolocation statistics...' });

      try {
        const res = await fetch(`/api/statistics?period=${currentTimeFilter}`);
        const data = await res.json();

        if (!data.success) {
          throw new Error('Failed to load statistics');
        }

        // Try to use coordinates from details.byIP
        let scatterData = [];
        if (data.data.details && Array.isArray(data.data.details.byIP)) {
          scatterData = data.data.details.byIP
            .filter(ipStat => typeof ipStat.latitude === 'number' && typeof ipStat.longitude === 'number' && ipStat.latitude !== null && ipStat.longitude !== null)
            .map(ipStat => [ipStat.longitude, ipStat.latitude, ipStat.count]);
        }

        if (scatterData.length > 0) {
          geoHeatmapChart.hideLoading();
          geoHeatmapChart.setOption({
            title: {
              text: 'Request Heatmap (by IP coordinates)',
              left: 'center',
              top: 10,
              textStyle: { fontSize: 18, fontWeight: 600 }
            },
            geo: {
              map: 'world',
              roam: true,
              label: { show: false },
              itemStyle: {
                areaColor: '#e0e7ef',
                borderColor: '#bfc8d8',
                borderWidth: 0.8
              },
              emphasis: {
                itemStyle: {
                  areaColor: '#b4d7f5'
                }
              }
            },
            visualMap: {
              min: 1,
              max: Math.max(10, ...scatterData.map(d => d[2])),
              text: ['High', 'Low'],
              realtime: false,
              calculable: true,
              inRange: {
                color: ['#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695']
              },
              left: 'left',
              top: 'bottom'
            },
            series: [{
              name: 'Requests',
              type: 'scatter',
              coordinateSystem: 'geo',
              data: scatterData,
              symbolSize: function (val) {
                return Math.max(8, Math.sqrt(val[2]) * 4);
              },
              encode: { tooltip: [2] },
              itemStyle: {
                color: '#4575b4',
                shadowBlur: 10,
                shadowColor: 'rgba(50, 50, 150, 0.3)'
              },
              emphasis: {
                itemStyle: {
                  color: '#d73027',
                  borderColor: '#fff',
                  borderWidth: 1.5
                }
              }
            }]
          });
          return;
        }

        // Aggregate country counts from the actual data structure
        const countryCounts = {};

        // Try to get data from routes (time period stats)
        if (data.data.routes && Array.isArray(data.data.routes)) {
          data.data.routes.forEach(route => {
            (route.topCountries || []).forEach(country => {
              if (country.country && country.country !== 'Unknown') {
                countryCounts[country.country] = (countryCounts[country.country] || 0) + country.count;
              }
            });
          });
        }

        // If no routes data, try to get from summary
        if (Object.keys(countryCounts).length === 0 && data.data.summary && data.data.summary.topCountries) {
          data.data.summary.topCountries.forEach(country => {
            if (country.country && country.country !== 'Unknown') {
              countryCounts[country.country] = country.count;
            }
          });
        }

        // If still no data, try to get from details
        if (Object.keys(countryCounts).length === 0 && data.data.details && data.data.details.byIP) {
          data.data.details.byIP.forEach(ipStat => {
            if (ipStat.location && ipStat.location !== 'Unknown') {
              const country = ipStat.location.split(', ').pop(); // Get last part (country)
              if (country && country !== 'Unknown') {
                countryCounts[country] = (countryCounts[country] || 0) + ipStat.count;
              }
            }
          });
        }

        // If still no data, try to get from the raw stats data
        if (Object.keys(countryCounts).length === 0 && data.data.stats) {
          data.data.stats.forEach(stat => {
            if (stat.geolocation && stat.geolocation.country && stat.geolocation.country !== 'Unknown') {
              countryCounts[stat.geolocation.country] = (countryCounts[stat.geolocation.country] || 0) + stat.count;
            }
          });
        }

        // Convert to ECharts format
        const mapData = Object.entries(countryCounts).map(([country, count]) => ({
          name: country,
          value: count
        }));

        if (mapData.length === 0) {
          container.innerHTML = '<div style="color:#718096;padding:2rem;text-align:center;">No geolocation data available for the selected time period</div>';
          return;
        }

        // Country code to name mapping for common countries
        const countryCodeToName = {
          'CA': 'Canada',
          'US': 'United States',
          'GB': 'United Kingdom',
          'DE': 'Germany',
          'FR': 'France',
          'IT': 'Italy',
          'ES': 'Spain',
          'NL': 'Netherlands',
          'BE': 'Belgium',
          'CH': 'Switzerland',
          'AT': 'Austria',
          'SE': 'Sweden',
          'NO': 'Norway',
          'DK': 'Denmark',
          'FI': 'Finland',
          'PL': 'Poland',
          'CZ': 'Czech Republic',
          'HU': 'Hungary',
          'RO': 'Romania',
          'BG': 'Bulgaria',
          'HR': 'Croatia',
          'SI': 'Slovenia',
          'SK': 'Slovakia',
          'LT': 'Lithuania',
          'LV': 'Latvia',
          'EE': 'Estonia',
          'IE': 'Ireland',
          'PT': 'Portugal',
          'GR': 'Greece',
          'CY': 'Cyprus',
          'MT': 'Malta',
          'LU': 'Luxembourg',
          'IS': 'Iceland',
          'LI': 'Liechtenstein',
          'MC': 'Monaco',
          'SM': 'San Marino',
          'VA': 'Vatican City',
          'AD': 'Andorra',
          'AU': 'Australia',
          'NZ': 'New Zealand',
          'JP': 'Japan',
          'KR': 'South Korea',
          'CN': 'China',
          'IN': 'India',
          'BR': 'Brazil',
          'AR': 'Argentina',
          'MX': 'Mexico',
          'CL': 'Chile',
          'PE': 'Peru',
          'CO': 'Colombia',
          'VE': 'Venezuela',
          'EC': 'Ecuador',
          'BO': 'Bolivia',
          'PY': 'Paraguay',
          'UY': 'Uruguay',
          'GY': 'Guyana',
          'SR': 'Suriname',
          'GF': 'French Guiana',
          'FK': 'Falkland Islands',
          'ZA': 'South Africa',
          'EG': 'Egypt',
          'NG': 'Nigeria',
          'KE': 'Kenya',
          'GH': 'Ghana',
          'ET': 'Ethiopia',
          'TZ': 'Tanzania',
          'UG': 'Uganda',
          'DZ': 'Algeria',
          'MA': 'Morocco',
          'TN': 'Tunisia',
          'LY': 'Libya',
          'SD': 'Sudan',
          'TD': 'Chad',
          'NE': 'Niger',
          'ML': 'Mali',
          'BF': 'Burkina Faso',
          'CI': 'Ivory Coast',
          'SN': 'Senegal',
          'GN': 'Guinea',
          'SL': 'Sierra Leone',
          'LR': 'Liberia',
          'TG': 'Togo',
          'BJ': 'Benin',
          'CM': 'Cameroon',
          'CF': 'Central African Republic',
          'CG': 'Republic of the Congo',
          'CD': 'Democratic Republic of the Congo',
          'GA': 'Gabon',
          'GQ': 'Equatorial Guinea',
          'ST': 'Sao Tome and Principe',
          'AO': 'Angola',
          'ZM': 'Zambia',
          'ZW': 'Zimbabwe',
          'BW': 'Botswana',
          'NA': 'Namibia',
          'SZ': 'Eswatini',
          'LS': 'Lesotho',
          'MG': 'Madagascar',
          'MU': 'Mauritius',
          'SC': 'Seychelles',
          'KM': 'Comoros',
          'DJ': 'Djibouti',
          'SO': 'Somalia',
          'ER': 'Eritrea',
          'RW': 'Rwanda',
          'BI': 'Burundi',
          'MW': 'Malawi',
          'MZ': 'Mozambique',
          'ZW': 'Zimbabwe',
          'BW': 'Botswana',
          'NA': 'Namibia',
          'SZ': 'Eswatini',
          'LS': 'Lesotho',
          'MG': 'Madagascar',
          'MU': 'Mauritius',
          'SC': 'Seychelles',
          'KM': 'Comoros',
          'DJ': 'Djibouti',
          'SO': 'Somalia',
          'ER': 'Eritrea',
          'RW': 'Rwanda',
          'BI': 'Burundi',
          'MW': 'Malawi',
          'MZ': 'Mozambique'
        };

        // Convert country codes to names and filter out non-standard entries
        const processedMapData = mapData
          .filter(item => item.name !== 'Local' && item.name !== 'Unknown')
          .map(item => ({
            name: countryCodeToName[item.name] || item.name,
            value: item.value
          }))
          .filter(item => item.value > 0);

        if (processedMapData.length === 0) {
          container.innerHTML = '<div style="color:#718096;padding:2rem;text-align:center;">No valid geolocation data available for the selected time period</div>';
          return;
        }

        geoHeatmapChart.setOption({
          title: {
            text: `Geolocation Heatmap (${currentTimeFilter})`,
            left: 'center',
            top: 10,
            textStyle: { fontSize: 20 }
          },
          tooltip: {
            trigger: 'item',
            formatter: params => `${params.name}: ${params.value || 0} requests`
          },
          visualMap: {
            min: 0,
            max: Math.max(10, ...processedMapData.map(d => d.value)),
            text: ['High', 'Low'],
            realtime: false,
            calculable: true,
            inRange: {
              color: ['#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695', '#a50026']
            },
            left: 'left',
            bottom: 30
          },
          series: [{
            name: 'Requests',
            type: 'map',
            map: 'world',
            roam: true,
            emphasis: { label: { show: true } },
            data: processedMapData
          }]
        });

        geoHeatmapChart.hideLoading();
        geoHeatmapLoaded = true;
      } catch (err) {
        console.error('Error rendering heatmap:', err);
        container.innerHTML = '<div style="color:#e53e3e;padding:2rem;text-align:center;">Failed to load geolocation statistics</div>';
      }
    }

    // Certificate functions
    async function loadCertificates() {
      try {
        const response = await fetch('/api/certificates');
        const data = await response.json();

        if (data.success) {
          certificatesData = data.data;
          updateCertificatesDisplay();
        } else {
          console.error('Failed to load certificates:', data.error);
        }
      } catch (error) {
        console.error('Failed to load certificates:', error);
      }
    }

    function updateCertificatesDisplay() {
      const { certificates, letsEncryptStatus } = certificatesData;

      // Update status cards
      document.getElementById('certificates-count').textContent = letsEncryptStatus.totalCertificates;
      document.getElementById('valid-certificates').textContent = letsEncryptStatus.validCertificates;
      document.getElementById('expiring-soon').textContent = letsEncryptStatus.expiringSoon;
      document.getElementById('expired-certificates').textContent = letsEncryptStatus.expired;

      const letsEncryptMode = letsEncryptStatus.staging ? 'Staging' : 'Production';
      document.getElementById('letsencrypt-status').textContent = letsEncryptMode;

      // Update certificates table
      const container = document.getElementById('certificates-container');

      if (!certificates || certificates.length === 0) {
        container.innerHTML = '<div class="no-data">No certificates found</div>';
        return;
      }

      const letsEncryptInfo = `
        <div class="letsencrypt-config">
          <div class="letsencrypt-header">
            <div class="letsencrypt-title">
              <div class="letsencrypt-icon">ðŸ”’</div>
              <div>
                <h3>Let's Encrypt Configuration</h3>
                <p class="letsencrypt-subtitle">SSL Certificate Management</p>
              </div>
            </div>
            <div class="letsencrypt-status-badge ${letsEncryptStatus.staging ? 'staging' : 'production'}">
              ${letsEncryptStatus.staging ? 'Staging' : 'Production'}
            </div>
          </div>
          
          <div class="letsencrypt-content">
            <div class="letsencrypt-section">
              <h4>Account Information</h4>
              <div class="letsencrypt-grid">
                <div class="letsencrypt-item">
                  <div class="letsencrypt-item-icon">ðŸ“§</div>
                  <div class="letsencrypt-item-content">
                    <div class="letsencrypt-item-label">Email</div>
                    <div class="letsencrypt-item-value">${letsEncryptStatus.email}</div>
                  </div>
                </div>
                <div class="letsencrypt-item">
                  <div class="letsencrypt-item-icon">ðŸ“</div>
                  <div class="letsencrypt-item-content">
                    <div class="letsencrypt-item-label">Certificate Directory</div>
                    <div class="letsencrypt-item-value">${letsEncryptStatus.certDir}</div>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="letsencrypt-section">
              <h4>Certificate Summary</h4>
              <div class="certificate-summary">
                <div class="certificate-summary-item">
                  <div class="certificate-summary-number">${letsEncryptStatus.totalCertificates}</div>
                  <div class="certificate-summary-label">Total</div>
                </div>
                <div class="certificate-summary-item valid">
                  <div class="certificate-summary-number">${letsEncryptStatus.validCertificates}</div>
                  <div class="certificate-summary-label">Valid</div>
                </div>
                <div class="certificate-summary-item warning">
                  <div class="certificate-summary-number">${letsEncryptStatus.expiringSoon}</div>
                  <div class="certificate-summary-label">Expiring Soon</div>
                </div>
                <div class="certificate-summary-item error">
                  <div class="certificate-summary-number">${letsEncryptStatus.expired}</div>
                  <div class="certificate-summary-label">Expired</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;

      const certificatesHtml = certificates.map(cert => {
        const now = new Date();
        const expiryDate = new Date(cert.expiresAt);
        const daysUntilExpiry = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));

        let status = 'valid';
        let statusText = 'Valid';

        if (expiryDate < now) {
          status = 'expired';
          statusText = 'Expired';
        } else if (daysUntilExpiry <= 30) {
          status = 'expiring-soon';
          statusText = `Expires in ${daysUntilExpiry} days`;
        }

        return `
          <div class="certificate-card">
            <div class="certificate-header">
              <div class="certificate-info">
                <div class="certificate-name">${cert.domain}</div>
                <div class="certificate-path">${cert.certPath}</div>
              </div>
              <div class="certificate-status ${status}">${statusText}</div>
            </div>
            <div class="certificate-details">
              <div class="certificate-detail">
                <div class="certificate-detail-label">Valid Until</div>
                <div class="certificate-detail-value">${new Date(cert.expiresAt).toLocaleString()}</div>
              </div>
              <div class="certificate-detail">
                <div class="certificate-detail-label">Days Until Expiry</div>
                <div class="certificate-detail-value ${daysUntilExpiry <= 30 ? 'warning' : daysUntilExpiry <= 0 ? 'error' : 'success'}">${daysUntilExpiry}</div>
              </div>
              <div class="certificate-detail">
                <div class="certificate-detail-label">Status</div>
                <div class="certificate-detail-value ${cert.isValid ? 'success' : 'error'}">${cert.isValid ? 'Valid' : 'Invalid'}</div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      container.innerHTML = letsEncryptInfo + certificatesHtml;
    }

    // Utility functions
    function formatUptime(milliseconds) {
      const totalSeconds = milliseconds / 1000;
      const seconds = Math.floor(totalSeconds);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) return `${days}d ${hours % 24}h`;
      if (hours > 0) return `${hours}h ${minutes % 60}m`;
      if (minutes > 0) return `${minutes}m ${(seconds % 60).toString().padStart(2, '0')}s`;
      return `${seconds.toString().padStart(2, '0')}s`;
    }

    function getRestartCountClass(count) {
      if (count === 0) return 'success';
      if (count <= 3) return 'warning';
      return 'error';
    }

    function formatNumber(num) {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      }
      return num.toString();
    }

    function formatResponseTime(ms) {
      if (ms < 1000) {
        return ms.toFixed(0) + 'ms';
      } else {
        return (ms / 1000).toFixed(2) + 's';
      }
    }

    function showNotification(message, type) {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;

      document.body.appendChild(notification);

      setTimeout(() => notification.classList.add('show'), 100);
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 3000);
    }

    // Clean up all live updates
    function cleanupLiveUpdates() {
      Object.keys(logUpdateIntervals).forEach(processId => {
        stopLiveLogUpdates(processId);
      });
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanupLiveUpdates);

    // Handle window resize for ECharts
    window.addEventListener('resize', () => {
      if (geoHeatmapChart) {
        geoHeatmapChart.resize();
      }
    });

    // Check if user is at bottom of logs
    function checkIfAtBottom(logsContainer) {
      if (!logsContainer) return true;

      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return true;

      const scrollTop = logLinesContainer.scrollTop;
      const scrollHeight = logLinesContainer.scrollHeight;
      const clientHeight = logLinesContainer.clientHeight;

      // Consider "at bottom" if within 5 pixels of the bottom
      return (scrollHeight - scrollTop - clientHeight) <= 5;
    }

    // Add scroll event listener to track when user scrolls away from bottom
    function setupLogScrollListener(processId) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) return;

      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return;

      // Remove existing listener if any
      logLinesContainer.removeEventListener('scroll', logLinesContainer._scrollHandler);

      // Add new scroll listener
      logLinesContainer._scrollHandler = () => {
        isAtBottom = checkIfAtBottom(logsContainer);
      };

      logLinesContainer.addEventListener('scroll', logLinesContainer._scrollHandler);
    }

    // Manually scroll to bottom and enable auto-follow
    function scrollToBottom(processId) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) return;

      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return;

      logLinesContainer.scrollTop = logLinesContainer.scrollHeight;
      isAtBottom = true;
    }

    // Initialize WebSocket connection
    connectWebSocket();

    // Add toggleDetails function for collapsible details
    function toggleDetails(processId) {
      const details = document.getElementById(`details-${processId}`);
      if (details) {
        details.classList.toggle('open');
      }
    }

    // Cache Management Functions
    function switchCacheTab(tab) {
      // Remove active class from all cache tabs
      document.querySelectorAll('.cache-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.cache-tab-content').forEach(c => c.classList.remove('active'));

      // Show selected tab
      document.getElementById(`cache-tab-${tab}`).classList.add('active');
      document.getElementById(`cache-content-${tab}`).classList.add('active');

      activeCacheTab = tab;

      // Load data for specific cache tabs
      if (tab === 'overview') {
        loadCacheStats();
      } else if (tab === 'users') {
        loadCacheUsers();
      } else if (tab === 'entries') {
        loadCacheEntries();
      }
    }

    async function loadCacheStats() {
      try {
        const response = await fetch('/api/cache/stats');
        if (!response.ok) throw new Error('Failed to load cache stats');

        const result = await response.json();
        const stats = result.data || {};
        cacheData = stats;

        // Update overview stats
        document.getElementById('cache-total-entries').textContent = stats.totalEntries || 0;
        document.getElementById('cache-mru-entries').textContent = stats.mruEntries || 0;
        document.getElementById('cache-total-size').textContent = formatBytes(stats.totalSize || 0);
        document.getElementById('cache-active-users').textContent = stats.activeUsers || 0;
        document.getElementById('cache-hit-rate').textContent = `${((stats.hitRate || 0) * 100).toFixed(1)}%`;

        // Update detailed stats in overview tab
        if (activeCacheTab === 'overview') {
          updateCacheStatsDisplay(stats);
        }
      } catch (error) {
        console.error('Failed to load cache stats:', error);
        showNotification('Failed to load cache statistics', 'error');
      }
    }

    async function loadCacheUsers() {
      try {
        const response = await fetch('/api/cache/users');
        if (!response.ok) throw new Error('Failed to load cache users');

        const result = await response.json();
        const users = Array.isArray(result.data) ? result.data : [];
        cacheUsers = users;

        updateCacheUsersDisplay(users);
      } catch (error) {
        console.error('Failed to load cache users:', error);
        showNotification('Failed to load cache users', 'error');
      }
    }

    async function loadCacheEntries(page = 1) {
      try {
        const limit = document.getElementById('cache-entries-limit')?.value || 50;
        const userFilter = document.getElementById('cache-user-filter')?.value || '';
        const mruFilter = document.getElementById('cache-mru-filter')?.value || '';

        let url = `/api/cache/entries?page=${page}&limit=${limit}`;
        if (userFilter) url += `&user=${encodeURIComponent(userFilter)}`;
        if (mruFilter) url += `&mru=${mruFilter}`;

        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to load cache entries');

        const result = await response.json();
        const data = result.data || {};
        const entries = Array.isArray(data.entries) ? data.entries : [];
        cacheEntries = entries;
        currentCachePage = page;

        updateCacheEntriesDisplay({ entries, pagination: data.pagination });
        updateCachePagination(data.pagination?.totalPages || 1, page);
      } catch (error) {
        console.error('Failed to load cache entries:', error);
        showNotification('Failed to load cache entries', 'error');
      }
    }

    function updateCacheStatsDisplay(stats) {
      const container = document.getElementById('cache-stats-container');
      if (!container) return;

      const html = `
        <div class="cache-stats-grid">
          <div class="cache-stat-item">
            <div class="cache-stat-value">${stats.totalEntries || 0}</div>
            <div class="cache-stat-label">Total Entries</div>
            <div class="cache-stat-description">All cached responses</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${stats.mruEntries || 0}</div>
            <div class="cache-stat-label">MRU Entries</div>
            <div class="cache-stat-description">In-memory cache (max 100)</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${formatBytes(stats.totalSize || 0)}</div>
            <div class="cache-stat-label">Total Size</div>
            <div class="cache-stat-description">Disk storage used</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${stats.activeUsers || 0}</div>
            <div class="cache-stat-label">Active Users</div>
            <div class="cache-stat-description">Users with cached data</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${((stats.hitRate || 0) * 100).toFixed(1)}%</div>
            <div class="cache-stat-label">Hit Rate</div>
            <div class="cache-stat-description">Cache effectiveness</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${stats.expiredEntries || 0}</div>
            <div class="cache-stat-label">Expired Entries</div>
            <div class="cache-stat-description">Ready for cleanup</div>
          </div>
        </div>
      `;

      container.innerHTML = html;
    }

    function updateCacheUsersDisplay(users) {
      const container = document.getElementById('cache-users-container');
      if (!container) return;

      // Ensure users is an array
      const usersArray = Array.isArray(users) ? users : [];

      if (usersArray.length === 0) {
        container.innerHTML = '<div class="loading">No users with cached entries found</div>';
        return;
      }

      const html = usersArray.map(user => {
        // Ensure user object has required properties
        if (!user || typeof user !== 'object') return '';

        return `
          <div class="cache-user-card">
            <div class="cache-user-header">
              <div class="cache-user-id">${user.userId || 'Unknown'}</div>
              <div class="cache-user-actions">
                <button onclick="clearUserCache('${user.userId || ''}')" class="btn btn-stop">Clear User Cache</button>
              </div>
            </div>
            <div class="cache-user-stats">
              <div class="cache-user-stat">
                <div class="cache-user-stat-value">${user.entryCount || user.entries || 0}</div>
                <div class="cache-user-stat-label">Entries</div>
              </div>
              <div class="cache-user-stat">
                <div class="cache-user-stat-value">${formatBytes(user.totalSize || user.size || 0)}</div>
                <div class="cache-user-stat-label">Size</div>
              </div>
              <div class="cache-user-stat">
                <div class="cache-user-stat-value">${user.mruCount || user.mruEntries || 0}</div>
                <div class="cache-user-stat-label">MRU</div>
              </div>
              <div class="cache-user-stat">
                <div class="cache-user-stat-value">${formatRelativeTime(user.lastActivity || user.lastAccess || 0)}</div>
                <div class="cache-user-stat-label">Last Access</div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      container.innerHTML = html;
    }

    function updateCacheEntriesDisplay(data) {
      const container = document.getElementById('cache-entries-container');
      if (!container) return;

      const entries = data.entries || [];

      if (entries.length === 0) {
        container.innerHTML = '<div class="loading">No cache entries found</div>';
        return;
      }

      const html = entries.map(entry => `
        <div class="cache-entry">
          <div class="cache-entry-header">
            <div class="cache-entry-info">
              <div class="cache-entry-url">${entry.url}</div>
              <div class="cache-entry-meta">
                <span>User: ${entry.userId}</span>
                <span>Method: ${entry.method}</span>
                <span>Status: ${entry.status}</span>
                <span>Size: ${formatBytes(entry.size)}</span>
                <span>MRU: ${entry.inMru ? 'Yes' : 'No'}</span>
                <span>Created: ${formatRelativeTime(entry.createdAt)}</span>
                <span>Expires: ${formatRelativeTime(entry.expiresAt)}</span>
              </div>
            </div>
            <div class="cache-entry-actions">
              <button onclick="viewCacheEntry('${entry.key}')" class="btn btn-logs">View</button>
              <button onclick="deleteCacheEntry('${entry.key}')" class="btn btn-stop">Delete</button>
            </div>
          </div>
        </div>
      `).join('');

      container.innerHTML = html;
    }

    function updateCachePagination(totalPages, currentPage) {
      const prevBtn = document.getElementById('cache-prev-page');
      const nextBtn = document.getElementById('cache-next-page');
      const pageInfo = document.getElementById('cache-page-info');

      if (prevBtn) prevBtn.disabled = currentPage <= 1;
      if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
      if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
    }

    function changeCachePage(delta) {
      const newPage = currentCachePage + delta;
      if (newPage >= 1) {
        loadCacheEntries(newPage);
      }
    }

    function filterCacheEntries() {
      const userFilter = document.getElementById('cache-user-filter')?.value || '';
      const mruFilter = document.getElementById('cache-mru-filter')?.value || '';

      cacheFilters.user = userFilter;
      cacheFilters.mru = mruFilter;

      // Reset to first page when filtering
      loadCacheEntries(1);
    }

    async function clearAllCache() {
      if (!confirm('Are you sure you want to clear all cache entries? This action cannot be undone.')) {
        return;
      }

      try {
        const response = await fetch('/api/cache/clear', { method: 'POST' });
        if (!response.ok) throw new Error('Failed to clear cache');

        showNotification('All cache entries cleared successfully', 'success');
        loadCacheStats();
        if (activeCacheTab === 'users') loadCacheUsers();
        if (activeCacheTab === 'entries') loadCacheEntries(1);
      } catch (error) {
        console.error('Failed to clear cache:', error);
        showNotification('Failed to clear cache', 'error');
      }
    }

    async function cleanupExpiredCache() {
      try {
        const response = await fetch('/api/cache/cleanup', { method: 'POST' });
        if (!response.ok) throw new Error('Failed to cleanup expired cache');

        const result = await response.json();
        showNotification(`Cleaned up ${result.cleanedEntries || 0} expired cache entries`, 'success');
        loadCacheStats();
        if (activeCacheTab === 'users') loadCacheUsers();
        if (activeCacheTab === 'entries') loadCacheEntries(1);
      } catch (error) {
        console.error('Failed to cleanup expired cache:', error);
        showNotification('Failed to cleanup expired cache', 'error');
      }
    }

    async function clearUserCache(userId) {
      if (!confirm(`Are you sure you want to clear all cache entries for user "${userId}"?`)) {
        return;
      }

      try {
        const response = await fetch(`/api/cache/clear-user/${encodeURIComponent(userId)}`, { method: 'POST' });
        if (!response.ok) throw new Error('Failed to clear user cache');

        showNotification(`Cache cleared for user "${userId}"`, 'success');
        loadCacheStats();
        if (activeCacheTab === 'users') loadCacheUsers();
        if (activeCacheTab === 'entries') loadCacheEntries(1);
      } catch (error) {
        console.error('Failed to clear user cache:', error);
        showNotification('Failed to clear user cache', 'error');
      }
    }

    async function deleteCacheEntry(key) {
      if (!confirm('Are you sure you want to delete this cache entry?')) {
        return;
      }

      try {
        const response = await fetch(`/api/cache/delete/${encodeURIComponent(key)}`, { method: 'DELETE' });
        if (!response.ok) throw new Error('Failed to delete cache entry');

        showNotification('Cache entry deleted successfully', 'success');
        loadCacheEntries(currentCachePage);
      } catch (error) {
        console.error('Failed to delete cache entry:', error);
        showNotification('Failed to delete cache entry', 'error');
      }
    }

    async function viewCacheEntry(key) {
      try {
        const response = await fetch(`/api/cache/entry/${encodeURIComponent(key)}`);
        if (!response.ok) throw new Error('Failed to load cache entry');

        const entry = await response.json();

        // Create a modal to display the cache entry
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
        `;

        const content = document.createElement('div');
        content.style.cssText = `
          background: white;
          border-radius: 8px;
          padding: 2rem;
          max-width: 90%;
          max-height: 90%;
          overflow: auto;
          position: relative;
        `;

        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Ã—';
        closeBtn.style.cssText = `
          position: absolute;
          top: 1rem;
          right: 1rem;
          background: none;
          border: none;
          font-size: 2rem;
          cursor: pointer;
          color: #666;
        `;
        closeBtn.onclick = () => document.body.removeChild(modal);

        const preview = entry.body.length > 1000 ?
          entry.body.substring(0, 1000) + '... [truncated]' :
          entry.body;

        content.innerHTML = `
          <h2>Cache Entry: ${entry.url}</h2>
          <div style="margin-bottom: 1rem;">
            <strong>User:</strong> ${entry.userId}<br>
            <strong>Method:</strong> ${entry.method}<br>
            <strong>Status:</strong> ${entry.status}<br>
            <strong>Content-Type:</strong> ${entry.contentType}<br>
            <strong>Size:</strong> ${formatBytes(entry.size)}<br>
            <strong>Created:</strong> ${formatLocalTime(entry.createdAt)}<br>
            <strong>Expires:</strong> ${formatLocalTime(entry.expiresAt)}
          </div>
          <h3>Response Body Preview:</h3>
          <div class="cache-entry-preview">${preview}</div>
        `;

        content.appendChild(closeBtn);
        modal.appendChild(content);
        document.body.appendChild(modal);

        // Close modal when clicking outside
        modal.onclick = (e) => {
          if (e.target === modal) {
            document.body.removeChild(modal);
          }
        };

      } catch (error) {
        console.error('Failed to view cache entry:', error);
        showNotification('Failed to load cache entry', 'error');
      }
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Configuration Editor Functions
    let currentConfigType = 'proxy';
    let currentConfigContent = '';

    function switchConfigTab(type) {
      document.querySelectorAll('.config-tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.config-tab-content').forEach(content => content.classList.remove('active'));

      document.getElementById(`config-tab-${type}`).classList.add('active');
      document.getElementById(`config-content-${type}`).classList.add('active');

      currentConfigType = type;
      loadConfig(type);
    }

    async function loadConfig(type) {
      try {
        const response = await fetch(`/api/config/${type}`);
        const data = await response.json();

        if (data.success) {
          const editor = document.getElementById(`${type}-config-editor`);
          const pathSpan = document.getElementById(`${type}-config-path`);
          const modifiedSpan = document.getElementById(`${type}-config-modified`);
          const validation = document.getElementById(`${type}-config-validation`);

          if (editor) editor.value = data.data.content;
          if (pathSpan) pathSpan.textContent = data.data.path;
          if (modifiedSpan) modifiedSpan.textContent = formatLocalTime(data.data.lastModified);
          if (validation) {
            validation.textContent = 'Configuration loaded successfully';
            validation.className = 'validation-message success';
          }
        } else {
          throw new Error(data.error || 'Failed to load configuration');
        }
      } catch (error) {
        console.error(`Failed to load ${type} configuration:`, error);
        const validation = document.getElementById(`${type}-config-validation`);
        if (validation) {
          validation.textContent = `Failed to load configuration: ${error.message}`;
          validation.className = 'validation-message error';
        }
      }
    }

    async function backupConfig(type) {
      try {
        const response = await fetch(`/api/config/${type}/backup`, { method: 'POST' });
        const data = await response.json();

        if (data.success) {
          showNotification('Configuration backup created successfully', 'success');
        } else {
          throw new Error(data.error || 'Failed to create backup');
        }
      } catch (error) {
        console.error(`Failed to backup ${type} configuration:`, error);
        showNotification(`Failed to create backup: ${error.message}`, 'error');
      }
    }

    async function saveConfig(type) {
      const editor = document.getElementById(`${type}-config-editor`);
      if (!editor) return;

      const content = editor.value;
      const createBackup = confirm('Create a backup before saving? (Recommended)');

      try {
        const response = await fetch(`/api/config/${type}/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content, createBackup })
        });

        const data = await response.json();

        if (data.success) {
          currentConfigContent = content;
          showNotification('Configuration saved successfully', 'success');

          const validation = document.getElementById(`${type}-config-validation`);
          if (validation) {
            validation.textContent = 'Configuration saved successfully';
            validation.className = 'validation-message success';
          }
        } else {
          throw new Error(data.error || 'Failed to save configuration');
        }
      } catch (error) {
        console.error(`Failed to save ${type} configuration:`, error);
        showNotification(`Failed to save configuration: ${error.message}`, 'error');

        const validation = document.getElementById(`${type}-config-validation`);
        if (validation) {
          validation.textContent = `Failed to save configuration: ${error.message}`;
          validation.className = 'validation-message error';
        }
      }
    }

    async function showBackups(type) {
      try {
        const response = await fetch(`/api/config/${type}/backups`);
        const data = await response.json();

        if (data.success) {
          const modal = document.getElementById('backup-modal');
          const backupList = document.getElementById('backup-list');

          if (backupList) {
            if (data.data.length === 0) {
              backupList.innerHTML = '<div class="loading">No backups found</div>';
            } else {
              backupList.innerHTML = data.data.map(backup => `
                <div class="backup-item">
                  <div class="backup-info">
                    <div class="backup-name">${backup.name}</div>
                    <div class="backup-meta">
                      Size: ${formatBytes(backup.size)} | 
                      Modified: ${formatLocalTime(backup.lastModified)}
                    </div>
                  </div>
                  <div class="backup-actions">
                    <button onclick="restoreBackup('${type}', '${backup.path}')" class="btn btn-start">Restore</button>
                  </div>
                </div>
              `).join('');
            }
          }

          if (modal) modal.style.display = 'block';
        } else {
          throw new Error(data.error || 'Failed to load backups');
        }
      } catch (error) {
        console.error(`Failed to load ${type} backups:`, error);
        showNotification(`Failed to load backups: ${error.message}`, 'error');
      }
    }

    function closeBackupModal() {
      const modal = document.getElementById('backup-modal');
      if (modal) modal.style.display = 'none';
    }

    async function restoreBackup(type, backupPath) {
      if (!confirm('Are you sure you want to restore this backup? This will overwrite the current configuration.')) {
        return;
      }

      try {
        const response = await fetch(`/api/config/${type}/restore`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ backupPath })
        });

        const data = await response.json();

        if (data.success) {
          showNotification('Configuration restored successfully', 'success');
          closeBackupModal();
          loadConfig(type);
        } else {
          throw new Error(data.error || 'Failed to restore backup');
        }
      } catch (error) {
        console.error(`Failed to restore ${type} backup:`, error);
        showNotification(`Failed to restore backup: ${error.message}`, 'error');
      }
    }

    // Override showTab function to handle config tab
    const originalShowTab = showTab;
    showTab = function (tab, pushState = true) {
      originalShowTab(tab, pushState);

      if (tab === 'config') {
        loadConfig(currentConfigType);
      }
    };

    // Close modal when clicking outside
    window.onclick = function (event) {
      const modal = document.getElementById('backup-modal');
      if (event.target === modal) {
        closeBackupModal();
      }
    };

    // Update individual process uptimes periodically
    function updateProcessUptimes() {
      const processes = Array.isArray(processesData) ? processesData : [];
      processes.forEach(process => {
        if (process && process.startTime && process.isRunning) {
          const processUptime = Date.now() - new Date(process.startTime).getTime();
          const uptimeElement = document.querySelector(`#process-content-${process.id} .process-tab-info-item:nth-child(3) .process-tab-info-value`);
          if (uptimeElement) {
            uptimeElement.textContent = formatUptime(processUptime);
          }
        }
      });
    }

    // Start periodic process uptime updates
    function startProcessUptimeUpdates() {
      // Update process uptimes every second
      setInterval(updateProcessUptimes, 1000);
    }
  </script>
</body>

</html>