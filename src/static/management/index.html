<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proxy Server Management</title>
  <!-- ECharts CDN for world map heatmap -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/extension/dataTool.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/extension/bmap.min.js"></script>
  <!-- Removed world.js due to MIME type issues - will use built-in world map data -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: #f5f7fa;
      color: #2d3748;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Tab bar styles */
    .tab-bar {
      display: flex;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 8px 8px 0 0;
      overflow: hidden;
      margin-bottom: 2rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.08);
    }
    
    .tab {
      flex: 1;
      padding: 1.2rem 0;
      text-align: center;
      color: #fff;
      font-size: 1.2rem;
      font-weight: 600;
      cursor: pointer;
      background: none;
      border: none;
      outline: none;
      transition: background 0.2s, color 0.2s;
    }
    
    .tab.active {
      background: rgba(255,255,255,0.15);
      color: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    
    .tab:not(.active):hover {
      background: rgba(255,255,255,0.08);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    .header p {
      opacity: 0.9;
      font-size: 1.1rem;
    }

    .connection-status {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-weight: 500;
      font-size: 0.9rem;
      display: inline-block;
    }

    .connection-status.connected {
      background: rgba(34, 197, 94, 0.1);
      color: #16a34a;
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .connection-status.disconnected {
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .status-cards, .stats-overview {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .card, .stat-card {
      background: white;
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
    }

    .card h3, .stat-card h4 {
      color: #4a5568;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .card .value, .stat-card .value {
      font-size: 2rem;
      font-weight: bold;
      color: #2d3748;
    }

    .refresh-btn {
      background: #4299e1;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      margin-bottom: 2rem;
      transition: background-color 0.2s;
    }

    .refresh-btn:hover {
      background: #3182ce;
    }

    .refresh-btn:disabled {
      background: #a0aec0;
      cursor: not-allowed;
    }

    .processes-section, .routes-section, .certificates-section {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      margin-bottom: 2rem;
    }

    .processes-section h2, .routes-section h2, .certificates-section h2 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1.5rem;
    }

    .section-description {
      color: #718096;
      font-size: 0.95rem;
      margin-bottom: 1.5rem;
      font-style: italic;
    }

    .process {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      transition: box-shadow 0.2s;
    }

    .process:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .process-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 1rem;
      min-height: 4rem;
      gap: 1rem;
      transition: all 0.2s ease;
      border: 1px solid #e2e8f0;
      cursor: pointer;
      position: relative;
    }

    .process-header:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      transform: translateY(-1px);
    }

    .process-header::after {
      content: '▼';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
      color: #718096;
      font-size: 0.8rem;
      transition: transform 0.2s ease;
    }

    .process-header.expanded::after {
      transform: translateY(-50%) rotate(180deg);
    }

    .process-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 3rem;
    }

    .process-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.5rem;
      line-height: 1.2;
    }

    .process-details {
      font-size: 0.9rem;
      color: #718096;
      margin-top: 0.25rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: flex-start;
    }

    .process-details span {
      white-space: nowrap;
      min-width: fit-content;
      height: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.25rem 0.5rem;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #e9ecef;
      font-weight: 500;
      font-size: 0.85rem;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      line-height: 1;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 1rem;
    }

    .process-details span.success {
      background: #d4edda;
      border-color: #c3e6cb;
      color: #155724;
    }

    .process-details span.warning {
      background: #fff3cd;
      border-color: #ffeaa7;
      color: #856404;
    }

    .process-details span.error {
      background: #f8d7da;
      border-color: #f5c6cb;
      color: #721c24;
    }

    .process-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: bold;
      text-transform: uppercase;
    }

    .status-running {
      background: #c6f6d5;
      color: #22543d;
    }

    .status-stopped {
      background: #fed7d7;
      color: #742a2a;
    }

    .status-warning {
      background: #fef5e7;
      color: #744210;
    }

    .status-error {
      background: #fed7d7;
      color: #742a2a;
    }

    .process-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      min-height: 3rem;
      justify-content: flex-end;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.9rem;
      transition: all 0.2s;
      height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 80px;
      white-space: nowrap;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-start {
      background: #48bb78;
      color: white;
    }

    .btn-start:hover:not(:disabled) {
      background: #38a169;
    }

    .btn-stop {
      background: #f56565;
      color: white;
    }

    .btn-stop:hover:not(:disabled) {
      background: #e53e3e;
    }

    .btn-restart {
      background: #ed8936;
      color: white;
    }

    .btn-restart:hover:not(:disabled) {
      background: #dd6b20;
    }

    .btn-logs {
      background: #4299e1;
      color: white;
    }

    .btn-logs:hover {
      background: #3182ce;
    }

    .process-body {
      padding: 1rem;
      display: none;
    }

    .process-body.expanded {
      display: block;
    }

    .process-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .metric {
      text-align: center;
    }

    .metric-label {
      font-size: 0.8rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metric-value {
      font-size: 1.2rem;
      font-weight: bold;
      padding: 1rem;
      color: #2d3748;
    }

    .metric-value.warning {
      color: #d69e2e;
    }

    .metric-value.error {
      color: #e53e3e;
    }

    .metric-value.success {
      color: #38a169;
    }

    .restart-history {
      background: #f7fafc;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .restart-history h4 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .restart-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid #e2e8f0;
    }

    .restart-item:last-child {
      border-bottom: none;
    }

    .restart-time {
      font-size: 0.9rem;
      color: #4a5568;
    }

    .restart-count {
      font-weight: bold;
      color: #2d3748;
    }

    .logs-container {
      background: #1a202c;
      color: #e2e8f0;
      border-radius: 6px;
      padding: 1rem;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.3;
      position: relative;
    }

    .logs-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #4a5568;
    }

    .logs-title {
      font-weight: bold;
      color: #e2e8f0;
    }

    .logs-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
    }

    .logs-controls select {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
    }

    .logs-filter-buttons {
      display: flex;
      gap: 0.25rem;
    }

    .logs-filter-btn {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .logs-filter-btn:hover {
      background: #4a5568;
    }

    .logs-filter-btn.active {
      background: #4299e1;
      border-color: #4299e1;
    }

    .logs-filter-btn.all {
      background: #48bb78;
      border-color: #48bb78;
    }

    .logs-filter-btn.all.active {
      background: #38a169;
      border-color: #38a169;
    }

    .logs-filter-btn.stdout {
      background: #4299e1;
      border-color: #4299e1;
    }

    .logs-filter-btn.stdout.active {
      background: #3182ce;
      border-color: #3182ce;
    }

    .logs-filter-btn.stderr {
      background: #f56565;
      border-color: #f56565;
    }

    .logs-filter-btn.stderr.active {
      background: #e53e3e;
      border-color: #e53e3e;
    }

    .logs-since-restart {
      background: #805ad5;
      border-color: #805ad5;
    }

    .logs-since-restart.active {
      background: #6b46c1;
      border-color: #6b46c1;
    }

    .logs-since-restart:hover {
      background: #6b46c1;
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #48bb78;
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: #48bb78;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }

    .log-line {
      margin-bottom: 0.1rem;
      word-wrap: break-word;
      padding: 0.05rem 0;
      white-space: pre-wrap;
    }

    .log-line:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .log-line.stdout {
      border-left: 3px solid #4299e1;
      padding-left: 0.5rem;
    }

    .log-line.stderr {
      border-left: 3px solid #f56565;
      padding-left: 0.5rem;
      background: rgba(245, 101, 101, 0.1);
    }

    .log-line.stderr:hover {
      background: rgba(245, 101, 101, 0.15);
    }

    .log-line.hidden {
      display: none;
    }

    .logs-content {
      max-height: 320px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .logs-content::-webkit-scrollbar {
      width: 8px;
    }

    .logs-content::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 4px;
    }

    .logs-content::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }

    .logs-content::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }

    .logs-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #718096;
      font-style: italic;
    }

    .logs-error {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #f56565;
      font-weight: 500;
    }

    /* Time filter styles */
    .time-filter {
      background: white;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
    }

    .time-filter h3 {
      margin-bottom: 1rem;
      color: #2d3748;
    }

    .filter-buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .filter-btn {
      background: #e2e8f0;
      color: #4a5568;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }

    .filter-btn.active {
      background: #4299e1;
      color: white;
    }

    .filter-btn:hover {
      background: #4299e1;
      color: white;
    }

    /* Routes table styles */
    .routes-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }

    .routes-table th,
    .routes-table td {
      padding: 1rem;
      text-align: left;
      border-bottom: 1px solid #e2e8f0;
    }

    .routes-table th {
      background: #f7fafc;
      font-weight: 600;
      color: #4a5568;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .routes-table tr:hover {
      background: #f7fafc;
    }

    .route-domain {
      font-weight: 600;
      color: #2d3748;
    }

    .route-target {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .request-count {
      font-weight: 600;
      color: #2d3748;
    }

    .geolocation {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .country-flag {
      width: 20px;
      height: 15px;
      border-radius: 2px;
      object-fit: cover;
    }

    .country-name {
      font-size: 0.9rem;
      color: #4a5568;
    }

    /* Certificate styles */
    .certificate-card {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      background: #f7fafc;
    }

    .certificate-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .certificate-name {
      font-weight: 600;
      color: #2d3748;
      font-size: 1.1rem;
    }

    .certificate-status {
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-weight: 500;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .certificate-status.valid {
      background: rgba(34, 197, 94, 0.1);
      color: #16a34a;
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .certificate-status.expired {
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .certificate-status.expiring-soon {
      background: rgba(245, 158, 11, 0.1);
      color: #d97706;
      border: 1px solid rgba(245, 158, 11, 0.2);
    }

    .certificate-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .certificate-detail {
      display: flex;
      flex-direction: column;
    }

    .certificate-detail-label {
      font-weight: 500;
      color: #4a5568;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }

    .certificate-detail-value {
      color: #2d3748;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
    }

    .letsencrypt-info {
      background: #f7fafc;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
      border: 1px solid #e2e8f0;
    }

    .letsencrypt-info h4 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .letsencrypt-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      font-size: 0.9rem;
    }

    .letsencrypt-detail {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
    }

    .letsencrypt-detail .label {
      color: #4a5568;
      font-weight: 500;
    }

    .letsencrypt-detail .value {
      color: #2d3748;
      font-weight: 600;
    }

    /* Geolocation heatmap */
    #geo-heatmap {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      margin-bottom: 2rem;
    }

    /* Utility classes */
    .loading {
      text-align: center;
      color: #718096;
      font-style: italic;
    }

    .error {
      background: #fed7d7;
      color: #742a2a;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .success {
      background: #c6f6d5;
      color: #22543d;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1rem 1.5rem;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.3s ease;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background: #48bb78;
    }

    .notification.error {
      background: #f56565;
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }

      .header h1 {
        font-size: 2rem;
      }

      .process-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
        min-height: auto;
        padding: 0.75rem;
      }

      .process-info {
        min-height: auto;
        width: 100%;
      }

      .process-actions {
        flex-wrap: wrap;
        gap: 0.5rem;
        width: 100%;
        justify-content: flex-start;
        min-height: auto;
      }

      .btn {
        height: 2.25rem;
        min-width: 70px;
        font-size: 0.85rem;
        padding: 0.4rem 0.8rem;
      }

      .process-details {
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
        justify-content: flex-start;
      }

      .process-details span {
        font-size: 0.85rem;
        height: 1.4rem;
        padding: 0.2rem 0.4rem;
        width: 100%;
        justify-content: flex-start;
      }

      .routes-table {
        font-size: 0.8rem;
      }

      .routes-table th,
      .routes-table td {
        padding: 0.5rem;
      }

      .letsencrypt-details {
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }

      .letsencrypt-detail {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
      }
    }

    /* Process tabs styles */
    .process-tabs {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }

    .process-tabs-header {
      display: flex;
      background: #f7fafc;
      border-bottom: 1px solid #e2e8f0;
      overflow-x: auto;
    }

    .process-tab {
      padding: 1rem 1.5rem;
      background: transparent;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: #4a5568;
      border-bottom: 3px solid transparent;
      white-space: nowrap;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      min-width: 120px;
    }

    .process-tab:hover {
      background: #edf2f7;
      color: #2d3748;
    }

    .process-tab.active {
      background: white;
      color: #2d3748;
      border-bottom-color: #4299e1;
    }

    .process-tab-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .process-tab-status.running {
      background: #48bb78;
    }

    .process-tab-status.stopped {
      background: #f56565;
    }

    .process-tab-status.warning {
      background: #ed8936;
    }

    .process-tab-content {
      display: none;
      padding: 1rem 0.5rem;
      margin-bottom: 0.5rem;
    }

    .process-tab-content.active {
      display: block;
    }

    .process-tab-actions {
      display: flex;
      gap: 0.25rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .process-tab-actions .btn {
      min-width: 70px;
      font-size: 0.85rem;
      padding: 0.3rem 0.7rem;
      height: 2rem;
    }

    .process-tab-info {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .process-tab-info-item {
      background: #f7fafc;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      border: 1px solid #e2e8f0;
      min-width: 120px;
      font-size: 0.85rem;
    }

    .process-tab-section {
      margin-bottom: 1rem;
    }

    .process-tab-section.collapsible {
      display: none;
    }

    .process-tab-section.collapsible.open {
      display: block;
    }

    .process-tab-info-label {
      font-size: 0.8rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }

    .process-tab-info-value {
      font-weight: 500;
      color: #2d3748;
      font-size: 0.9rem;
    }

    .process-tab-info-value.success {
      color: #38a169;
    }

    .process-tab-info-value.warning {
      color: #d69e2e;
    }

    .process-tab-info-value.error {
      color: #e53e3e;
    }

    .process-tab-info-value.time-display {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
      color: #4a5568;
      background: #f7fafc;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
      border: 1px solid #e2e8f0;
    }

    .process-tab-info-value.relative-time {
      font-style: italic;
      color: #718096;
      font-size: 0.8rem;
    }

    .process-tab-section {
      margin-bottom: 2rem;
    }

    .process-tab-section h3 {
      color: #2d3748;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .no-processes-tab {
      padding: 3rem;
      text-align: center;
      color: #718096;
    }

    .no-processes-tab h3 {
      color: #4a5568;
      margin-bottom: 0.5rem;
    }

    .process-tab-scroll {
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: #cbd5e0 #f7fafc;
    }

    .process-tab-scroll::-webkit-scrollbar {
      height: 6px;
    }

    .process-tab-scroll::-webkit-scrollbar-track {
      background: #f7fafc;
    }

    .process-tab-scroll::-webkit-scrollbar-thumb {
      background: #cbd5e0;
      border-radius: 3px;
    }

    .process-tab-scroll::-webkit-scrollbar-thumb:hover {
      background: #a0aec0;
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #48bb78;
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: #48bb78;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .follow-btn {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .follow-btn:hover {
      background: #4a5568;
    }

    .follow-btn.active {
      background: #48bb78;
      border-color: #48bb78;
      color: white;
    }

    .follow-btn.inactive {
      background: #f56565;
      border-color: #f56565;
      color: white;
    }

    .live-indicator.following {
      color: #48bb78;
    }

    .live-indicator.not-following {
      color: #f56565;
    }

    .live-indicator.not-following .live-dot {
      background: #f56565;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="tab-bar">
      <button class="tab active" id="tab-processes" onclick="showTab('processes')">🚀 Processes</button>
      <button class="tab" id="tab-statistics" onclick="showTab('statistics')">📊 Statistics</button>
      <button class="tab" id="tab-certificates" onclick="showTab('certificates')">🔒 Certificates</button>
    </div>
    
    <!-- Processes Tab -->
    <div id="content-processes" class="tab-content active">
      <div class="header">
        <h1>⚙️ Process Management</h1>
        <p>Monitor and control managed processes</p>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>Total Processes</h4>
          <div class="value" id="processes-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Running</h4>
          <div class="value" id="running-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Stopped</h4>
          <div class="value" id="stopped-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Uptime</h4>
          <div class="value" id="uptime">-</div>
        </div>
        <div class="stat-card">
          <h4>Last Updated</h4>
          <div class="value" id="last-updated">-</div>
        </div>
      </div>

      <div class="process-tabs" id="process-tabs">
        <div class="process-tabs-header process-tab-scroll" id="process-tabs-header">
          <!-- Process tabs will be generated here -->
        </div>
        <div id="process-tabs-content">
          <!-- Process tab content will be generated here -->
        </div>
      </div>
    </div>

    <!-- Statistics Tab -->
    <div id="content-statistics" class="tab-content">
      <div class="header">
        <h1>📊 HTTP Service Statistics</h1>
        <p>Monitor proxy traffic, routes, and geolocation data</p>
      </div>

      <!-- World map heatmap for geolocation statistics -->
      <div id="geo-heatmap" style="width:100%;height:500px;"></div>

      <div class="time-filter">
        <h3>Time Period</h3>
        <div class="filter-buttons">
          <button class="filter-btn active" onclick="setTimeFilter('1h')">1 Hour</button>
          <button class="filter-btn" onclick="setTimeFilter('24h')">24 Hours</button>
          <button class="filter-btn" onclick="setTimeFilter('7d')">7 Days</button>
          <button class="filter-btn" onclick="setTimeFilter('30d')">30 Days</button>
        </div>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>Total Requests</h4>
          <div class="value" id="totalRequests">-</div>
        </div>
        <div class="stat-card">
          <h4>Unique IPs</h4>
          <div class="value" id="uniqueIPs">-</div>
        </div>
        <div class="stat-card">
          <h4>Active Routes</h4>
          <div class="value" id="activeRoutes">-</div>
        </div>
        <div class="stat-card">
          <h4>Countries</h4>
          <div class="value" id="uniqueCountries">-</div>
        </div>
        <div class="stat-card">
          <h4>Avg Response Time</h4>
          <div class="value" id="avgResponseTime">-</div>
        </div>
      </div>

      <div class="routes-section">
        <h2>Route Statistics</h2>
        <div id="routesTable">
          <div class="loading">Loading route statistics...</div>
        </div>
      </div>
    </div>

    <!-- Certificates Tab -->
    <div id="content-certificates" class="tab-content">
      <div class="header">
        <h1>🔒 SSL Certificates</h1>
        <p>Manage SSL certificates and Let's Encrypt configuration</p>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>SSL Certificates</h4>
          <div class="value" id="certificates-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Valid Certificates</h4>
          <div class="value" id="valid-certificates">-</div>
        </div>
        <div class="stat-card">
          <h4>Expiring Soon</h4>
          <div class="value" id="expiring-soon">-</div>
        </div>
        <div class="stat-card">
          <h4>Expired</h4>
          <div class="value" id="expired-certificates">-</div>
        </div>
        <div class="stat-card">
          <h4>Let's Encrypt</h4>
          <div class="value" id="letsencrypt-status">-</div>
        </div>
      </div>

      <div class="certificates-section">
        <h2>SSL Certificates</h2>
        <p class="section-description">Let's Encrypt certificate status and expiration information</p>
        <button onclick="loadCertificates()" class="refresh-btn">🔄 Refresh Certificates</button>
        <div id="certificates-container">
          <div class="loading">Loading certificates...</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Utility function to format timestamps in local time
    function formatLocalTime(timestamp) {
      if (!timestamp) return 'N/A';
      
      try {
        const date = new Date(timestamp);
        if (isNaN(date.getTime())) return 'Invalid Date';
        
        // Format the date in local region format
        const localDate = date.toLocaleString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
        
        // Calculate elapsed time
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);
        
        let elapsedText = '';
        if (diffDays > 0) {
          elapsedText = ` (${diffDays} day${diffDays > 1 ? 's' : ''} ago)`;
        } else if (diffHours > 0) {
          elapsedText = ` (${diffHours} hour${diffHours > 1 ? 's' : ''} ago)`;
        } else if (diffMinutes > 0) {
          elapsedText = ` (${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago)`;
        } else {
          elapsedText = ' (just now)';
        }
        
        return `${localDate}${elapsedText}`;
      } catch (error) {
        return 'Invalid Date';
      }
    }

    // Utility function to format relative time (e.g., "2 hours ago")
    function formatRelativeTime(timestamp) {
      if (!timestamp) return 'N/A';
      
      try {
        const date = new Date(timestamp);
        if (isNaN(date.getTime())) return 'Invalid Date';
        
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);
        
        if (diffDays > 0) {
          return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        } else if (diffHours > 0) {
          return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        } else if (diffMinutes > 0) {
          return `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago`;
        } else {
          return 'Just now';
        }
      } catch (error) {
        return 'Invalid Date';
      }
    }

    // Global variables
    let ws = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    const reconnectDelay = 2000;
    let processesData = [];
    let statusData = {};
    let liveUpdateIntervals = {};
    let currentTimeFilter = '24h';
    let geoHeatmapChart = null;
    let geoHeatmapLoaded = false;
    let certificatesData = {};
    let currentLogLines = 100;
    let logUpdateIntervals = {};
    let activeProcessTab = null;
    let currentLogFilter = 'all'; // 'all', 'stdout', 'stderr'
    let processLogs = {}; // Store logs for each process with stream info
    let showLogsSinceRestart = false; // Track if we should show logs since last restart
    let processLastRestartTimes = {}; // Store last restart times for each process
    let isAtBottom = true; // Track if user is at bottom of logs for auto-follow

    // Tab switching logic
    function showTab(tab, pushState = true) {
      // Hide all tabs
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      
      // Show selected tab
      document.getElementById(`tab-${tab}`).classList.add('active');
      document.getElementById(`content-${tab}`).classList.add('active');
      
      // Load data for specific tabs
      if (tab === 'statistics') {
        if (!geoHeatmapLoaded) {
          renderGeoHeatmap();
        }
        loadStatistics();
      } else if (tab === 'certificates') {
        loadCertificates();
      }

      // Update history state
      if (pushState) {
        const state = { tab, process: activeProcessTab };
        const url = `#${tab}` + (activeProcessTab ? `-${activeProcessTab}` : '');
        window.history.pushState(state, '', url);
      }
    }

    function switchProcessTab(processId, pushState = true) {
      // Remove active class from all tabs
      document.querySelectorAll('.process-tab').forEach(tab => {
        tab.classList.remove('active');
      });

      // Hide all tab content
      document.querySelectorAll('.process-tab-content').forEach(content => {
        content.classList.remove('active');
      });

      // Activate the selected tab
      const selectedTab = document.querySelector(`[data-process-id="${processId}"]`);
      if (selectedTab) {
        selectedTab.classList.add('active');
      }

      // Show the corresponding content
      const selectedContent = document.getElementById(`process-content-${processId}`);
      if (selectedContent) {
        selectedContent.classList.add('active');
      }

      // Update active process tab
      activeProcessTab = processId;

      // Reset "since restart" state when switching tabs
      showLogsSinceRestart = false;

      // Request logs for the active tab
      requestLogs(processId, currentLogLines);

      // Set up live updates for this process
      setupLiveUpdates(processId);

      // Update history state
      if (pushState) {
        // Find the currently active main tab
        const activeTab = document.querySelector('.tab.active');
        const tab = activeTab ? activeTab.id.replace('tab-', '') : 'processes';
        const state = { tab, process: processId };
        const url = `#${tab}-${processId}`;
        window.history.pushState(state, '', url);
      }
    }

    // Handle browser navigation (back/forward)
    window.addEventListener('popstate', (event) => {
      const state = event.state;
      if (state) {
        // Restore tab
        showTab(state.tab || 'processes', false);
        // Restore process tab if present
        if (state.tab === 'processes' && state.process) {
          switchProcessTab(state.process, false);
        }
      } else {
        // Default to processes tab
        showTab('processes', false);
      }
    });

    // On page load, restore state from URL hash or default
    window.addEventListener('DOMContentLoaded', () => {
      let tab = 'processes';
      let process = null;
      if (window.location.hash) {
        const hash = window.location.hash.replace('#', '');
        const parts = hash.split('-');
        if (parts.length > 0) tab = parts[0];
        if (parts.length > 1) process = parts.slice(1).join('-');
      }
      showTab(tab, false);
      if (tab === 'processes' && process) {
        // Wait for processesData to be loaded, then switch
        const trySwitch = () => {
          if (processesData && processesData.find(p => p.id === process)) {
            switchProcessTab(process, false);
          } else {
            setTimeout(trySwitch, 100);
          }
        };
        trySwitch();
      }
    });

    // WebSocket connection management
    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws`;
      
      ws = new WebSocket(wsUrl);
      
      ws.onopen = function() {
        console.log('WebSocket connected');
        reconnectAttempts = 0;
        updateConnectionStatus(true);
      };
      
      ws.onmessage = function(event) {
        try {
          const message = JSON.parse(event.data);
          handleWebSocketMessage(message);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };
      
      ws.onclose = function() {
        console.log('WebSocket disconnected');
        updateConnectionStatus(false);
        
        // Attempt to reconnect
        if (reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
          setTimeout(connectWebSocket, reconnectDelay);
        } else {
          console.error('Max reconnection attempts reached');
          showNotification('WebSocket connection lost. Please refresh the page.', 'error');
        }
      };
      
      ws.onerror = function(error) {
        console.error('WebSocket error:', error);
      };
    }

    function updateConnectionStatus(connected) {
      const statusElement = document.getElementById('connection-status');
      if (statusElement) {
        statusElement.textContent = connected ? '🟢 Connected' : '🔴 Disconnected';
        statusElement.className = connected ? 'connected' : 'disconnected';
      }
    }

    function handleWebSocketMessage(message) {
      switch (message.type) {
        case 'processes':
          const oldProcessesData = processesData;
          processesData = message.data;
          
          // If this is the first load, update the entire display
          if (!oldProcessesData || oldProcessesData.length === 0) {
            updateProcessesDisplay();
          } else {
            // Update individual process information without regenerating HTML
            processesData.forEach(process => {
              updateProcessInfo(process.id, process);
            });
          }
          break;
        case 'status':
          statusData = message.data;
          updateStatusDisplay();
          break;
        case 'logs':
          updateProcessLogs(message.data.processId, message.data.logs);
          break;
        case 'error':
          console.error('WebSocket error:', message.data);
          showNotification('WebSocket error: ' + message.data.message, 'error');
          break;
        case 'pong':
          // Handle ping/pong for connection health
          break;
        default:
          console.warn('Unknown WebSocket message type:', message.type);
      }
    }

    function requestLogs(processId, lines = currentLogLines) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'request_logs',
          processId: processId,
          lines: lines
        }));
      }
    }

    function setLogLines(lines) {
      if (lines === 'all') {
        currentLogLines = 'all';
      } else {
        currentLogLines = parseInt(lines);
      }
      // Update active process tab with new line count
      if (activeProcessTab) {
        requestLogs(activeProcessTab, currentLogLines);
      }
    }

    function setLogFilter(filter) {
      currentLogFilter = filter;
      // Update active process tab with new filter
      if (activeProcessTab && processLogs[activeProcessTab]) {
        updateProcessLogsDisplay(activeProcessTab, processLogs[activeProcessTab]);
      }
    }

    function setLogsSinceRestart(enabled) {
      showLogsSinceRestart = enabled;
      // Update active process tab with new setting
      if (activeProcessTab && processLogs[activeProcessTab]) {
        updateProcessLogsDisplay(activeProcessTab, processLogs[activeProcessTab]);
      }
    }

    // Update status display
    function updateStatusDisplay() {
      const processesCount = statusData.processes?.length || 0;
      const runningCount = statusData.processes?.filter(p => p.status === 'running').length || 0;
      const stoppedCount = processesCount - runningCount;
      const uptime = statusData.uptime || 0;
      const timestamp = statusData.timestamp ? formatLocalTime(statusData.timestamp) : 'N/A';

      document.getElementById('processes-count').textContent = processesCount;
      document.getElementById('running-count').textContent = runningCount;
      document.getElementById('stopped-count').textContent = stoppedCount;
      document.getElementById('uptime').textContent = formatUptime(uptime * 1000);
      document.getElementById('last-updated').textContent = timestamp;
    }

    // Update process information fields without regenerating entire HTML
    function updateProcessInfo(processId, processData) {
      const processContent = document.getElementById(`process-content-${processId}`);
      if (!processContent) return;

      // Update status
      const statusElement = processContent.querySelector('.process-tab-info-item:first-child .process-tab-info-value');
      if (statusElement) {
        const statusClass = processData.status === 'running' ? 'success' : 'error';
        const statusText = processData.status === 'running' ? 'Running' : 'Stopped';
        statusElement.className = `process-tab-info-value ${statusClass}`;
        statusElement.textContent = statusText;
      }

      // Update PID
      const pidElement = processContent.querySelector('.process-tab-info-item:nth-child(2) .process-tab-info-value');
      if (pidElement) {
        pidElement.textContent = processData.pid || 'N/A';
      }

      // Update port
      const portElement = processContent.querySelector('.process-tab-info-item:nth-child(3) .process-tab-info-value');
      if (portElement) {
        portElement.textContent = processData.port || 'N/A';
      }

      // Update restart count
      const restartElement = processContent.querySelector('.process-tab-info-item:nth-child(4) .process-tab-info-value');
      if (restartElement) {
        restartElement.className = `process-tab-info-value ${getRestartCountClass(processData.restartAttempts || 0)}`;
        restartElement.textContent = processData.restartAttempts || 0;
      }

      // Update health failures
      const healthElement = processContent.querySelector('.process-tab-info-item:nth-child(5) .process-tab-info-value');
      if (healthElement) {
        healthElement.className = `process-tab-info-value ${getRestartCountClass(processData.healthFailures || 0)}`;
        healthElement.textContent = processData.healthFailures || 0;
      }

      // Update start time
      const startTimeElement = processContent.querySelector('.process-tab-info-item:nth-child(6) .process-tab-info-value');
      if (startTimeElement) {
        startTimeElement.textContent = processData.startTime ? formatLocalTime(processData.startTime) : 'N/A';
      }

      // Update last restart time
      const lastRestartElement = processContent.querySelector('.process-tab-info-item:nth-child(7) .process-tab-info-value');
      if (lastRestartElement) {
        lastRestartElement.textContent = processData.lastRestartTime ? formatLocalTime(processData.lastRestartTime) : 'N/A';
      }

      // Update uptime
      const uptimeElement = processContent.querySelector('.process-tab-info-item:nth-child(4) .process-tab-info-value');
      if (uptimeElement) {
        uptimeElement.textContent = processData.uptime ? formatUptime(processData.uptime) : 'N/A';
      }

      // Update restart history section
      const restartHistorySection = processContent.querySelector('.process-tab-section:first-of-type .process-tab-info');
      if (restartHistorySection) {
        // Update current session restarts
        const currentSessionElement = restartHistorySection.querySelector('.process-tab-info-item:first-child .process-tab-info-value');
        if (currentSessionElement) {
          currentSessionElement.textContent = `${processData.restartAttempts || 0} restarts`;
        }

        // Update last restart time in history section
        const lastRestartHistoryElement = restartHistorySection.querySelector('.process-tab-info-item:nth-child(2) .process-tab-info-value');
        if (lastRestartHistoryElement && processData.lastRestartTime) {
          lastRestartHistoryElement.textContent = formatLocalTime(processData.lastRestartTime);
        }

        // Update reconnected status
        const reconnectedElement = restartHistorySection.querySelector('.process-tab-info-item:last-child .process-tab-info-value');
        if (reconnectedElement && processData.isReconnected) {
          reconnectedElement.textContent = `Existing PID: ${processData.pid}`;
        }
      }

      // Update tab header status indicator
      const tabButton = document.querySelector(`[data-process-id="${processId}"]`);
      if (tabButton) {
        const statusIndicator = tabButton.querySelector('.process-tab-status');
        if (statusIndicator) {
          statusIndicator.className = `process-tab-status ${processData.status === 'running' ? 'running' : 'stopped'}`;
        }
      }

      // Update action buttons
      const startButton = processContent.querySelector('.btn-start');
      const stopButton = processContent.querySelector('.btn-stop');
      
      if (startButton) {
        startButton.disabled = processData.status === 'running';
      }
      if (stopButton) {
        stopButton.disabled = processData.status !== 'running';
      }
    }

    // Update processes display
    function updateProcessesDisplay() {
      const tabsHeader = document.getElementById('process-tabs-header');
      const tabsContent = document.getElementById('process-tabs-content');
      
      if (!processesData || processesData.length === 0) {
        tabsHeader.innerHTML = '';
        tabsContent.innerHTML = `
          <div class="no-processes-tab">
            <h3>No Processes Configured</h3>
            <p>No processes are currently configured or available.</p>
          </div>
        `;
        return;
      }

      // Preserve current active tab
      const currentActiveTab = activeProcessTab || (processesData.length > 0 ? processesData[0].id : null);

      // Generate tab headers
      const tabHeaders = processesData.map((process) => {
        const statusClass = process.status === 'running' ? 'running' : 'stopped';
        const isActive = process.id === currentActiveTab ? 'active' : '';
        
        return `
          <button class="process-tab ${isActive}" data-process-id="${process.id}" onclick="switchProcessTab('${process.id}')">
            <div class="process-tab-status ${statusClass}"></div>
            <span>${process.name || process.id}</span>
          </button>
        `;
      }).join('');

      // Generate tab content
      const tabContents = processesData.map((process) => {
        const isActive = process.id === currentActiveTab ? 'active' : '';
        const statusClass = process.status === 'running' ? 'success' : 'error';
        const statusText = process.status === 'running' ? 'Running' : 'Stopped';
        
        return `
          <div class="process-tab-content ${isActive}" id="process-content-${process.id}">
            <div class="process-tab-actions">
              <button onclick="startProcess('${process.id}')" class="btn btn-start" ${process.status === 'running' ? 'disabled' : ''}>
                Start
              </button>
              <button onclick="stopProcess('${process.id}')" class="btn btn-stop" ${process.status !== 'running' ? 'disabled' : ''}>
                Stop
              </button>
              <button onclick="restartProcess('${process.id}')" class="btn btn-restart">
                Restart
              </button>
            </div>
            <div class="process-tab-info">
              <div class="process-tab-info-item">
                <span class="process-tab-info-label">Status</span>
                <span class="process-tab-info-value ${statusClass}">${statusText}</span>
              </div>
              <div class="process-tab-info-item">
                <span class="process-tab-info-label">PID</span>
                <span class="process-tab-info-value">${process.pid || 'N/A'}</span>
              </div>
              <div class="process-tab-info-item">
                <span class="process-tab-info-label">Port</span>
                <span class="process-tab-info-value">${process.port || 'N/A'}</span>
              </div>
              <div class="process-tab-info-item">
                <span class="process-tab-info-label">Uptime</span>
                <span class="process-tab-info-value">${process.uptime ? formatUptime(process.uptime) : 'N/A'}</span>
              </div>
              <button class="btn btn-xs" onclick="toggleDetails('${process.id}')" style="margin-left: 1rem;">Details</button>
            </div>
            <div class="process-tab-section collapsible" id="details-${process.id}">
              <div class="process-tab-info">
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Restart Count</span>
                  <span class="process-tab-info-value ${getRestartCountClass(process.restartAttempts || 0)}">${process.restartAttempts || 0}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Health Failures</span>
                  <span class="process-tab-info-value ${getRestartCountClass(process.healthFailures || 0)}">${process.healthFailures || 0}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Start Time</span>
                  <span class="process-tab-info-value time-display">${process.startTime ? formatLocalTime(process.startTime) : 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Last Restart</span>
                  <span class="process-tab-info-value time-display">${process.lastRestartTime ? formatLocalTime(process.lastRestartTime) : 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Log File</span>
                  <span class="process-tab-info-value" style="font-size: 0.8rem;">${process.logFile || 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">PID File</span>
                  <span class="process-tab-info-value" style="font-size: 0.8rem;">${process.pidFile || 'N/A'}</span>
                </div>
              </div>
            </div>
            <div class="process-tab-section">
              <h3>📋 Process Logs</h3>
              <div class="logs-container" id="logs-${process.id}">
                <div class="logs-header">
                  <div class="logs-title">Process Logs</div>
                  <div class="logs-controls">
                    <select onchange="setLogLines(this.value)" title="Number of log lines to display">
                      <option value="100">100 lines</option>
                      <option value="500">500 lines</option>
                      <option value="1000">1,000 lines</option>
                      <option value="5000">5,000 lines</option>
                      <option value="10000">10,000 lines</option>
                      <option value="all">All logs</option>
                    </select>
                    <div class="logs-filter-buttons">
                      <button class="logs-filter-btn all active" onclick="setLogFilter('all')" title="Show all logs">All</button>
                      <button class="logs-filter-btn stdout" onclick="setLogFilter('stdout')" title="Show stdout only">STDOUT</button>
                      <button class="logs-filter-btn stderr" onclick="setLogFilter('stderr')" title="Show stderr only">STDERR</button>
                      <button class="logs-filter-btn logs-since-restart" onclick="setLogsSinceRestart(!showLogsSinceRestart)" title="Show logs since last restart">Since Restart</button>
                    </div>
                    <button class="follow-btn active" onclick="scrollToBottom('${process.id}')" title="Follow logs (scroll to bottom)">
                      <span>📋</span>
                      <span>Follow</span>
                    </button>
                    <div class="live-indicator following">
                      <div class="live-dot"></div>
                      <span>Live</span>
                    </div>
                  </div>
                </div>
                <div class="logs-loading">Click tab to load recent log entries</div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      tabsHeader.innerHTML = tabHeaders;
      tabsContent.innerHTML = tabContents;

      // Update active process tab if it changed
      if (currentActiveTab && currentActiveTab !== activeProcessTab) {
        activeProcessTab = currentActiveTab;
        // Request logs for the active tab if it's the first time
        if (!processLogs[currentActiveTab]) {
          requestLogs(currentActiveTab, currentLogLines);
          setupLiveUpdates(currentActiveTab);
        }
      } else if (!activeProcessTab && processesData.length > 0) {
        // Set the first process as active if no active tab
        switchProcessTab(processesData[0].id);
      }
    }

    // Process control functions
    async function startProcess(processId) {
      await performProcessAction(processId, 'start');
    }

    async function stopProcess(processId) {
      await performProcessAction(processId, 'stop');
    }

    async function restartProcess(processId) {
      await performProcessAction(processId, 'restart');
    }

    async function performProcessAction(processId, action) {
      try {
        const response = await fetch(`/api/processes/${processId}/${action}`, {
          method: 'POST'
        });

        const data = await response.json();

        if (data.success) {
          showNotification(`Process ${processId} ${action}ed successfully`, 'success');
          // WebSocket will automatically update the display
        } else {
          showNotification(`Failed to ${action} process: ` + data.error, 'error');
        }
      } catch (error) {
        showNotification(`Failed to ${action} process: ` + error.message, 'error');
      }
    }

    // Update process logs via WebSocket
    function updateProcessLogs(processId, logs) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) {
        return;
      }

      // Store last restart time for this process
      const process = processesData.find(p => p.id === processId);
      if (process && process.lastRestartTime) {
        processLastRestartTimes[processId] = new Date(process.lastRestartTime).getTime();
      }

      if (!logs || logs.length === 0) {
        logsContainer.innerHTML = `
          <div class="logs-header">
            <div class="logs-title">Process Logs</div>
            <div class="logs-controls">
              <select onchange="setLogLines(this.value)" title="Number of log lines to display">
                <option value="100">100 lines</option>
                <option value="500">500 lines</option>
                <option value="1000">1,000 lines</option>
                <option value="5000">5,000 lines</option>
                <option value="10000">10,000 lines</option>
                <option value="all">All logs</option>
              </select>
              <div class="logs-filter-buttons">
                <button class="logs-filter-btn all active" onclick="setLogFilter('all')" title="Show all logs">All</button>
                <button class="logs-filter-btn stdout" onclick="setLogFilter('stdout')" title="Show stdout only">STDOUT</button>
                <button class="logs-filter-btn stderr" onclick="setLogFilter('stderr')" title="Show stderr only">STDERR</button>
                <button class="logs-filter-btn logs-since-restart" onclick="setLogsSinceRestart(!showLogsSinceRestart)" title="Show logs since last restart">Since Restart</button>
              </div>
              <button class="follow-btn active" onclick="scrollToBottom('${processId}')" title="Follow logs (scroll to bottom)">
                <span>📋</span>
                <span>Follow</span>
              </button>
              <div class="live-indicator following">
                <div class="live-dot"></div>
                <span>Live</span>
              </div>
            </div>
          </div>
          <div class="logs-loading">No logs available</div>
        `;
        return;
      }

      // Store logs with stream information
      const logsWithStreams = logs.map(log => {
        // Parse log line to determine stream type
        // Look for explicit stream prefixes first
        if (log.includes('[STDOUT]')) {
          return {
            content: log,
            stream: 'stdout'
          };
        }
        
        if (log.includes('[STDERR]')) {
          return {
            content: log,
            stream: 'stderr'
          };
        }
        
        // Fallback to pattern matching for logs without explicit prefixes
        const isStderr = log.includes('ERROR') || 
                        log.includes('WARN') ||
                        log.includes('FATAL') ||
                        log.toLowerCase().includes('error') ||
                        log.toLowerCase().includes('warning') ||
                        log.toLowerCase().includes('fail') ||
                        log.toLowerCase().includes('exception');
        
        return {
          content: log,
          stream: isStderr ? 'stderr' : 'stdout'
        };
      });

      // Store logs for this process
      processLogs[processId] = logsWithStreams;

      // Update display with current filter
      updateProcessLogsDisplay(processId, logsWithStreams);
    }

    // Update process logs display with filtering
    function updateProcessLogsDisplay(processId, logsWithStreams) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) {
        return;
      }

      // Filter logs based on current filter
      let filteredLogs = logsWithStreams.filter(log => {
        if (currentLogFilter === 'all') return true;
        return log.stream === currentLogFilter;
      });

      // Apply "since last restart" filter if enabled
      if (showLogsSinceRestart && processLastRestartTimes[processId]) {
        const lastRestartTime = processLastRestartTimes[processId];
        filteredLogs = filteredLogs.filter(log => {
          // Try to extract timestamp from log line
          const timestampMatch = log.content.match(/\[(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\]/);
          if (timestampMatch) {
            const logTime = new Date(timestampMatch[1]).getTime();
            return logTime >= lastRestartTime;
          }
          // If no timestamp found, include the log (better to show than hide)
          return true;
        });
      }

      // Update filter button states
      const filterButtons = logsContainer.querySelectorAll('.logs-filter-btn');
      filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent.toLowerCase() === currentLogFilter || 
            (currentLogFilter === 'all' && btn.textContent === 'All')) {
          btn.classList.add('active');
        }
        // Handle "Since Restart" button state
        if (btn.textContent === 'Since Restart') {
          if (showLogsSinceRestart) {
            btn.classList.add('active');
          }
        }
      });

      // Use DocumentFragment for better performance with large log volumes
      const fragment = document.createDocumentFragment();
      const logLinesContainer = document.createElement('div');
      logLinesContainer.className = 'logs-content';

      // Process logs in chunks to avoid blocking the UI
      const chunkSize = 1000;
      const processLogsInChunks = (startIndex) => {
        const endIndex = Math.min(startIndex + chunkSize, filteredLogs.length);
        
        for (let i = startIndex; i < endIndex; i++) {
          const logLine = document.createElement('div');
          logLine.className = `log-line ${filteredLogs[i].stream}`;
          logLine.innerHTML = filteredLogs[i].content;
          logLinesContainer.appendChild(logLine);
        }

        if (endIndex < filteredLogs.length) {
          // Process next chunk asynchronously
          setTimeout(() => processLogsInChunks(endIndex), 0);
        } else {
          // All chunks processed, update the container
          const header = logsContainer.querySelector('.logs-header');
          logsContainer.innerHTML = '';
          logsContainer.appendChild(header);
          logsContainer.appendChild(logLinesContainer);
          
          // Only scroll to bottom if user was at bottom before update
          if (isAtBottom) {
            logLinesContainer.scrollTop = logLinesContainer.scrollHeight;
          }
          
          // Setup scroll listener for this log container
          setupLogScrollListener(processId);
        }
      };

      // Update header with log count
      const header = logsContainer.querySelector('.logs-header');
      if (header) {
        const title = header.querySelector('.logs-title');
        if (title) {
          const totalLogs = logsWithStreams.length;
          const filteredCount = filteredLogs.length;
          let filterText = '';
          if (currentLogFilter !== 'all') {
            filterText += ` (${currentLogFilter.toUpperCase()})`;
          }
          if (showLogsSinceRestart) {
            filterText += ' (since restart)';
          }
          
          // Add indicator for "all logs" mode
          let lineCountText = '';
          if (currentLogLines === 'all') {
            lineCountText = ` (All ${filteredCount.toLocaleString()}/${totalLogs.toLocaleString()} lines)`;
          } else {
            lineCountText = ` (${filteredCount.toLocaleString()}/${totalLogs.toLocaleString()} lines)`;
          }
          
          title.textContent = `Process Logs${filterText}${lineCountText}`;
        }
        
        // Update follow button and live indicator
        const followBtn = header.querySelector('.follow-btn');
        const liveIndicator = header.querySelector('.live-indicator');
        
        if (followBtn) {
          if (isAtBottom) {
            followBtn.className = 'follow-btn active';
            followBtn.title = 'Following logs (scroll to bottom)';
            followBtn.innerHTML = '<span>📋</span><span>Follow</span>';
          } else {
            followBtn.className = 'follow-btn inactive';
            followBtn.title = 'Not following - click to follow logs';
            followBtn.innerHTML = '<span>⏸️</span><span>Paused</span>';
          }
        }
        
        if (liveIndicator) {
          if (isAtBottom) {
            liveIndicator.className = 'live-indicator following';
            liveIndicator.innerHTML = '<div class="live-dot"></div><span>Live</span>';
          } else {
            liveIndicator.className = 'live-indicator not-following';
            liveIndicator.innerHTML = '<div class="live-dot"></div><span>Paused</span>';
          }
        }
        
        // Update dropdown selection
        const lineCountSelect = header.querySelector('select');
        if (lineCountSelect) {
          lineCountSelect.value = currentLogLines;
        }
      }

      // Start processing logs
      processLogsInChunks(0);
      
      // Show performance warning for very large log files
      if (currentLogLines === 'all' && filteredLogs.length > 50000) {
        setTimeout(() => {
          const warningDiv = document.createElement('div');
          warningDiv.className = 'logs-warning';
          warningDiv.innerHTML = `
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 4px; padding: 0.75rem; margin: 0.5rem 0; color: #92400e;">
              <strong>⚠️ Performance Notice:</strong> Displaying ${filteredLogs.length.toLocaleString()} log lines. 
              Large log files may impact browser performance. Consider using a smaller line count for better performance.
            </div>
          `;
          logsContainer.insertBefore(warningDiv, logsContainer.firstChild);
        }, 100);
      }
    }

    // Start live log updates for a process
    function setupLiveUpdates(processId) {
      // Stop live updates for other processes
      Object.keys(logUpdateIntervals).forEach(pid => {
        if (pid !== processId) {
          stopLiveLogUpdates(pid);
        }
      });

      // Start live updates for the current process
      startLiveLogUpdates(processId);
    }

    function startLiveLogUpdates(processId) {
      // Stop any existing interval for this process
      stopLiveLogUpdates(processId);
      
      // Request logs every 5 seconds via WebSocket
      logUpdateIntervals[processId] = setInterval(() => {
        requestLogs(processId, currentLogLines);
      }, 5000);
    }

    // Stop live log updates for a process
    function stopLiveLogUpdates(processId) {
      if (logUpdateIntervals[processId]) {
        clearInterval(logUpdateIntervals[processId]);
        delete logUpdateIntervals[processId];
      }
    }

    // Statistics functions
    function setTimeFilter(period) {
      currentTimeFilter = period;
      
      // Update active button
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      loadStatistics();
      if (geoHeatmapLoaded) {
        renderGeoHeatmap();
      }
    }

    async function loadStatistics() {
      try {
        const response = await fetch(`/api/statistics?period=${currentTimeFilter}`);
        const data = await response.json();
        
        if (data.success) {
          updateStatisticsDisplay(data.data);
        } else {
          console.error('Failed to load statistics:', data.error);
        }
      } catch (error) {
        console.error('Error loading statistics:', error);
      }
    }

    function updateStatisticsDisplay(data) {
      // Update overview cards
      document.getElementById('totalRequests').textContent = formatNumber(data.totalRequests || 0);
      document.getElementById('uniqueIPs').textContent = formatNumber(data.uniqueIPs || 0);
      document.getElementById('activeRoutes').textContent = (data.routes || []).length;
      document.getElementById('uniqueCountries').textContent = formatNumber(data.uniqueCountries || 0);
      document.getElementById('avgResponseTime').textContent = formatResponseTime(data.avgResponseTime || 0);
      
      // Update routes table
      const routesContainer = document.getElementById('routesTable');
      if (data.routes && data.routes.length > 0) {
        const routesHtml = `
          <table class="routes-table">
            <thead>
              <tr>
                <th>Domain</th>
                <th>Target</th>
                <th>Requests</th>
                <th>Top Countries</th>
                <th>Avg Response Time</th>
              </tr>
            </thead>
            <tbody>
              ${data.routes.map(route => `
                <tr>
                  <td class="route-domain">${route.domain}</td>
                  <td class="route-target">${route.target}</td>
                  <td class="request-count">${formatNumber(route.requestCount || route.requests || 0)}</td>
                  <td>
                    ${(route.topCountries || []).slice(0, 3).map(country => `
                      <div class="geolocation">
                        <img src="https://flagcdn.com/16x12/${country.countryCode?.toLowerCase() || 'xx'}.png" 
                             alt="${country.country}" 
                             class="country-flag"
                             onerror="this.style.display='none'">
                        <span class="country-name">${country.country} (${country.count})</span>
                      </div>
                    `).join('')}
                  </td>
                  <td>${formatResponseTime(route.avgResponseTime || 0)}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        `;
        routesContainer.innerHTML = routesHtml;
      } else {
        routesContainer.innerHTML = '<div class="loading">No route data available</div>';
      }
    }

    async function renderGeoHeatmap() {
      const container = document.getElementById('geo-heatmap');
      container.innerHTML = '';
      
      if (!window.echarts) {
        container.innerHTML = '<div style="color:#e53e3e;padding:2rem;text-align:center;">ECharts library not loaded</div>';
        return;
      }
      
      if (!geoHeatmapChart) {
        geoHeatmapChart = echarts.init(container);
      }
      
      geoHeatmapChart.showLoading('default', { text: 'Loading geolocation statistics...' });

      try {
        const res = await fetch(`/api/statistics?period=${currentTimeFilter}`);
        const data = await res.json();
        
        if (!data.success) {
          throw new Error('Failed to load statistics');
        }
        
        // Aggregate country counts from all routes
        const countryCounts = {};
        (data.data.routes || []).forEach(route => {
          (route.topCountries || []).forEach(c => {
            if (!c.country) return;
            countryCounts[c.country] = (countryCounts[c.country] || 0) + c.count;
          });
        });
        
        // Convert to ECharts format
        const mapData = Object.entries(countryCounts).map(([country, count]) => ({ 
          name: country, 
          value: count 
        }));
        
        geoHeatmapChart.setOption({
          title: {
            text: `Geolocation Heatmap (${currentTimeFilter})`,
            left: 'center',
            top: 10,
            textStyle: { fontSize: 20 }
          },
          tooltip: {
            trigger: 'item',
            formatter: params => `${params.name}: ${params.value || 0} requests`
          },
          visualMap: {
            min: 0,
            max: Math.max(10, ...mapData.map(d => d.value)),
            text: ['High','Low'],
            realtime: false,
            calculable: true,
            inRange: {
              color: ['#e0f3f8','#abd9e9','#74add1','#4575b4','#313695','#a50026']
            },
            left: 'left',
            bottom: 30
          },
          series: [{
            name: 'Requests',
            type: 'map',
            map: 'world',
            roam: true,
            emphasis: { label: { show: true } },
            data: mapData
          }]
        });
        
        geoHeatmapChart.hideLoading();
        geoHeatmapLoaded = true;
      } catch (err) {
        container.innerHTML = '<div style="color:#e53e3e;padding:2rem;text-align:center;">Failed to load geolocation statistics</div>';
      }
    }

    // Certificate functions
    async function loadCertificates() {
      try {
        const response = await fetch('/api/certificates');
        const data = await response.json();

        if (data.success) {
          certificatesData = data.data;
          updateCertificatesDisplay();
        } else {
          console.error('Failed to load certificates:', data.error);
        }
      } catch (error) {
        console.error('Failed to load certificates:', error);
      }
    }

    function updateCertificatesDisplay() {
      const { certificates, letsEncryptStatus } = certificatesData;

      // Update status cards
      document.getElementById('certificates-count').textContent = letsEncryptStatus.totalCertificates;
      document.getElementById('valid-certificates').textContent = letsEncryptStatus.validCertificates;
      document.getElementById('expiring-soon').textContent = letsEncryptStatus.expiringSoon;
      document.getElementById('expired-certificates').textContent = letsEncryptStatus.expired;
      
      const letsEncryptMode = letsEncryptStatus.staging ? 'Staging' : 'Production';
      document.getElementById('letsencrypt-status').textContent = letsEncryptMode;

      // Update certificates table
      const container = document.getElementById('certificates-container');
      
      if (!certificates || certificates.length === 0) {
        container.innerHTML = '<div class="no-data">No certificates found</div>';
        return;
      }

      const letsEncryptInfo = `
        <div class="letsencrypt-info">
          <h4>🔒 Let's Encrypt Configuration</h4>
          <div class="letsencrypt-details">
            <div class="letsencrypt-detail">
              <span class="label">Email:</span>
              <span class="value">${letsEncryptStatus.email}</span>
            </div>
            <div class="letsencrypt-detail">
              <span class="label">Environment:</span>
              <span class="value">${letsEncryptStatus.staging ? 'Staging' : 'Production'}</span>
            </div>
            <div class="letsencrypt-detail">
              <span class="label">Certificate Directory:</span>
              <span class="value">${letsEncryptStatus.certDir}</span>
            </div>
            <div class="letsencrypt-detail">
              <span class="label">Total Certificates:</span>
              <span class="value">${letsEncryptStatus.totalCertificates}</span>
            </div>
            <div class="letsencrypt-detail">
              <span class="label">Valid:</span>
              <span class="value">${letsEncryptStatus.validCertificates}</span>
            </div>
            <div class="letsencrypt-detail">
              <span class="label">Expiring Soon:</span>
              <span class="value">${letsEncryptStatus.expiringSoon}</span>
            </div>
            <div class="letsencrypt-detail">
              <span class="label">Expired:</span>
              <span class="value">${letsEncryptStatus.expired}</span>
            </div>
          </div>
        </div>
      `;

      const certificatesHtml = certificates.map(cert => {
        const now = new Date();
        const expiryDate = new Date(cert.expiresAt);
        const daysUntilExpiry = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));
        
        let status = 'valid';
        let statusText = 'Valid';
        
        if (expiryDate < now) {
          status = 'expired';
          statusText = 'Expired';
        } else if (daysUntilExpiry <= 30) {
          status = 'expiring-soon';
          statusText = `Expires in ${daysUntilExpiry} days`;
        }
        
        return `
          <div class="certificate-card">
            <div class="certificate-header">
              <div class="certificate-name">${cert.domain}</div>
              <div class="certificate-status ${status}">${statusText}</div>
            </div>
            <div class="certificate-details">
              <div class="certificate-detail">
                <div class="certificate-detail-label">Domain</div>
                <div class="certificate-detail-value">${cert.domain}</div>
              </div>
              <div class="certificate-detail">
                <div class="certificate-detail-label">Valid Until</div>
                <div class="certificate-detail-value">${new Date(cert.expiresAt).toLocaleString()}</div>
              </div>
              <div class="certificate-detail">
                <div class="certificate-detail-label">Days Until Expiry</div>
                <div class="certificate-detail-value">${daysUntilExpiry}</div>
              </div>
              <div class="certificate-detail">
                <div class="certificate-detail-label">Status</div>
                <div class="certificate-detail-value">${cert.isValid ? 'Valid' : 'Invalid'}</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = letsEncryptInfo + certificatesHtml;
    }

    // Utility functions
    function formatUptime(milliseconds) {
      const seconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) return `${days}d ${hours % 24}h`;
      if (hours > 0) return `${hours}h ${minutes % 60}m`;
      if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
      return `${seconds}s`;
    }

    function getRestartCountClass(count) {
      if (count === 0) return 'success';
      if (count <= 3) return 'warning';
      return 'error';
    }

    function formatNumber(num) {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      }
      return num.toString();
    }

    function formatResponseTime(ms) {
      if (ms < 1000) {
        return ms.toFixed(0) + 'ms';
      } else {
        return (ms / 1000).toFixed(2) + 's';
      }
    }

    function showNotification(message, type) {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;

      document.body.appendChild(notification);

      setTimeout(() => notification.classList.add('show'), 100);
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 3000);
    }

    // Clean up all live updates
    function cleanupLiveUpdates() {
      Object.keys(logUpdateIntervals).forEach(processId => {
        stopLiveLogUpdates(processId);
      });
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanupLiveUpdates);

    // Handle window resize for ECharts
    window.addEventListener('resize', () => {
      if (geoHeatmapChart) {
        geoHeatmapChart.resize();
      }
    });

    // Check if user is at bottom of logs
    function checkIfAtBottom(logsContainer) {
      if (!logsContainer) return true;
      
      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return true;
      
      const scrollTop = logLinesContainer.scrollTop;
      const scrollHeight = logLinesContainer.scrollHeight;
      const clientHeight = logLinesContainer.clientHeight;
      
      // Consider "at bottom" if within 5 pixels of the bottom
      return (scrollHeight - scrollTop - clientHeight) <= 5;
    }

    // Add scroll event listener to track when user scrolls away from bottom
    function setupLogScrollListener(processId) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) return;
      
      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return;
      
      // Remove existing listener if any
      logLinesContainer.removeEventListener('scroll', logLinesContainer._scrollHandler);
      
      // Add new scroll listener
      logLinesContainer._scrollHandler = () => {
        isAtBottom = checkIfAtBottom(logsContainer);
      };
      
      logLinesContainer.addEventListener('scroll', logLinesContainer._scrollHandler);
    }

    // Manually scroll to bottom and enable auto-follow
    function scrollToBottom(processId) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) return;
      
      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return;
      
      logLinesContainer.scrollTop = logLinesContainer.scrollHeight;
      isAtBottom = true;
    }

    // Initialize WebSocket connection
    connectWebSocket();

    // Add toggleDetails function for collapsible details
    function toggleDetails(processId) {
      const details = document.getElementById(`details-${processId}`);
      if (details) {
        details.classList.toggle('open');
      }
    }
  </script>
</body>

</html>