<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proxy Server Management</title>
  <!-- ECharts CDN for world map heatmap -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/extension/dataTool.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/extension/bmap.min.js"></script>
  <!-- Removed world.js due to MIME type issues - will use built-in world map data -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: #f5f7fa;
      color: #2d3748;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Tab bar styles */
    .tab-bar {
      display: flex;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 8px 8px 0 0;
      overflow: hidden;
      margin-bottom: 2rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.08);
    }
    
    .tab {
      flex: 1;
      padding: 1.2rem 0;
      text-align: center;
      color: #fff;
      font-size: 1.2rem;
      font-weight: 600;
      cursor: pointer;
      background: none;
      border: none;
      outline: none;
      transition: background 0.2s, color 0.2s;
    }
    
    .tab.active {
      background: rgba(255,255,255,0.15);
      color: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    
    .tab:not(.active):hover {
      background: rgba(255,255,255,0.08);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    .header p {
      opacity: 0.9;
      font-size: 1.1rem;
    }

    .connection-status {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-weight: 500;
      font-size: 0.9rem;
      display: inline-block;
    }

    .connection-status.connected {
      background: rgba(34, 197, 94, 0.1);
      color: #16a34a;
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .connection-status.disconnected {
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .status-cards, .stats-overview {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .card, .stat-card {
      background: white;
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
    }

    .card h3, .stat-card h4 {
      color: #4a5568;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .card .value, .stat-card .value {
      font-size: 2rem;
      font-weight: bold;
      color: #2d3748;
    }

    .refresh-btn {
      background: #4299e1;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      margin-bottom: 2rem;
      transition: background-color 0.2s;
    }

    .refresh-btn:hover {
      background: #3182ce;
    }

    .refresh-btn:disabled {
      background: #a0aec0;
      cursor: not-allowed;
    }

    .processes-section, .routes-section, .certificates-section {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      margin-bottom: 2rem;
    }

    .processes-section h2, .routes-section h2, .certificates-section h2 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1.5rem;
    }

    .section-description {
      color: #718096;
      font-size: 0.95rem;
      margin-bottom: 1.5rem;
      font-style: italic;
    }

    .process {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      transition: box-shadow 0.2s;
    }

    .process:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .process-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 1rem;
      min-height: 4rem;
      gap: 1rem;
      transition: all 0.2s ease;
      border: 1px solid #e2e8f0;
      cursor: pointer;
      position: relative;
    }

    .process-header:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      transform: translateY(-1px);
    }

    .process-header::after {
      content: '▼';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
      color: #718096;
      font-size: 0.8rem;
      transition: transform 0.2s ease;
    }

    .process-header.expanded::after {
      transform: translateY(-50%) rotate(180deg);
    }

    .process-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 3rem;
    }

    .process-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.5rem;
      line-height: 1.2;
    }

    .process-details {
      font-size: 0.9rem;
      color: #718096;
      margin-top: 0.25rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: flex-start;
    }

    .process-details span {
      white-space: nowrap;
      min-width: fit-content;
      height: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.25rem 0.5rem;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #e9ecef;
      font-weight: 500;
      font-size: 0.85rem;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      line-height: 1;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 1rem;
    }

    .process-details span.success {
      background: #d4edda;
      border-color: #c3e6cb;
      color: #155724;
    }

    .process-details span.warning {
      background: #fff3cd;
      border-color: #ffeaa7;
      color: #856404;
    }

    .process-details span.error {
      background: #f8d7da;
      border-color: #f5c6cb;
      color: #721c24;
    }

    .process-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: bold;
      text-transform: uppercase;
    }

    .status-running {
      background: #c6f6d5;
      color: #22543d;
    }

    .status-stopped {
      background: #fed7d7;
      color: #742a2a;
    }

    .status-warning {
      background: #fef5e7;
      color: #744210;
    }

    .status-error {
      background: #fed7d7;
      color: #742a2a;
    }

    .process-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      min-height: 3rem;
      justify-content: flex-end;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.9rem;
      transition: all 0.2s;
      height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 80px;
      white-space: nowrap;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-start {
      background: #48bb78;
      color: white;
    }

    .btn-start:hover:not(:disabled) {
      background: #38a169;
    }

    .btn-stop {
      background: #f56565;
      color: white;
    }

    .btn-stop:hover:not(:disabled) {
      background: #e53e3e;
    }

    .btn-restart {
      background: #ed8936;
      color: white;
    }

    .btn-restart:hover:not(:disabled) {
      background: #dd6b20;
    }

    .btn-logs {
      background: #4299e1;
      color: white;
    }

    .btn-logs:hover {
      background: #3182ce;
    }

    .process-body {
      padding: 1rem;
      display: none;
    }

    .process-body.expanded {
      display: block;
    }

    .process-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .metric {
      text-align: center;
    }

    .metric-label {
      font-size: 0.8rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metric-value {
      font-size: 1.2rem;
      font-weight: bold;
      padding: 1rem;
      color: #2d3748;
    }

    .metric-value.warning {
      color: #d69e2e;
    }

    .metric-value.error {
      color: #e53e3e;
    }

    .metric-value.success {
      color: #38a169;
    }

    .restart-history {
      background: #f7fafc;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .restart-history h4 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .restart-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid #e2e8f0;
    }

    .restart-item:last-child {
      border-bottom: none;
    }

    .restart-time {
      font-size: 0.9rem;
      color: #4a5568;
    }

    .restart-count {
      font-weight: bold;
      color: #2d3748;
    }

    .logs-container {
      background: #1a202c;
      color: #e2e8f0;
      border-radius: 6px;
      padding: 1rem;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.3;
      position: relative;
    }

    .logs-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #4a5568;
    }

    .logs-title {
      font-weight: bold;
      color: #e2e8f0;
    }

    .logs-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
    }

    .logs-controls select {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
    }

    .logs-filter-buttons {
      display: flex;
      gap: 0.25rem;
    }

    .logs-filter-btn {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .logs-filter-btn:hover {
      background: #4a5568;
    }

    .logs-filter-btn.active {
      background: #4299e1;
      border-color: #4299e1;
    }

    .logs-filter-btn.all {
      background: #48bb78;
      border-color: #48bb78;
    }

    .logs-filter-btn.all.active {
      background: #38a169;
      border-color: #38a169;
    }

    .logs-filter-btn.stdout {
      background: #4299e1;
      border-color: #4299e1;
    }

    .logs-filter-btn.stdout.active {
      background: #3182ce;
      border-color: #3182ce;
    }

    .logs-filter-btn.stderr {
      background: #f56565;
      border-color: #f56565;
    }

    .logs-filter-btn.stderr.active {
      background: #e53e3e;
      border-color: #e53e3e;
    }

    .logs-since-restart {
      background: #805ad5;
      border-color: #805ad5;
    }

    .logs-since-restart.active {
      background: #6b46c1;
      border-color: #6b46c1;
    }

    .logs-since-restart:hover {
      background: #6b46c1;
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #48bb78;
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: #48bb78;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }

    .log-line {
      margin-bottom: 0.1rem;
      word-wrap: break-word;
      padding: 0.05rem 0;
      white-space: pre-wrap;
    }

    .log-line:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .log-line.stdout {
      border-left: 3px solid #4299e1;
      padding-left: 0.5rem;
    }

    .log-line.stderr {
      border-left: 3px solid #f56565;
      padding-left: 0.5rem;
      background: rgba(245, 101, 101, 0.1);
    }

    .log-line.stderr:hover {
      background: rgba(245, 101, 101, 0.15);
    }

    .log-line.hidden {
      display: none;
    }

    .logs-content {
      max-height: 320px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .logs-content::-webkit-scrollbar {
      width: 8px;
    }

    .logs-content::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 4px;
    }

    .logs-content::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }

    .logs-content::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }

    .logs-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #718096;
      font-style: italic;
    }

    .logs-error {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #f56565;
      font-weight: 500;
    }

    /* Time filter styles */
    .time-filter {
      background: white;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
    }

    .time-filter h3 {
      margin-bottom: 1rem;
      color: #2d3748;
    }

    .filter-buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .filter-btn {
      background: #e2e8f0;
      color: #4a5568;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }

    .filter-btn.active {
      background: #4299e1;
      color: white;
    }

    .filter-btn:hover {
      background: #4299e1;
      color: white;
    }

    /* Routes table styles */
    .routes-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }

    .routes-table th,
    .routes-table td {
      padding: 1rem;
      text-align: left;
      border-bottom: 1px solid #e2e8f0;
    }

    .routes-table th {
      background: #f7fafc;
      font-weight: 600;
      color: #4a5568;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .routes-table tr:hover {
      background: #f7fafc;
    }

    .route-domain {
      font-weight: 600;
      color: #2d3748;
    }

    .route-target {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .request-count {
      font-weight: 600;
      color: #2d3748;
    }

    .geolocation {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .country-flag {
      width: 20px;
      height: 15px;
      border-radius: 2px;
      object-fit: cover;
    }

    .country-name {
      font-size: 0.9rem;
      color: #4a5568;
    }

    /* Certificate styles */
    .certificate-card {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease;
    }

    .certificate-card:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    .certificate-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      gap: 1rem;
    }

    .certificate-info {
      flex: 1;
    }

    .certificate-name {
      font-weight: 700;
      color: #1a202c;
      font-size: 1.25rem;
      margin-bottom: 0.5rem;
    }

    .certificate-path {
      font-size: 0.85rem;
      color: #718096;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      word-break: break-all;
    }

    .certificate-status {
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
    }

    .certificate-status.valid {
      background: rgba(34, 197, 94, 0.1);
      color: #16a34a;
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .certificate-status.expired {
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .certificate-status.expiring-soon {
      background: rgba(245, 158, 11, 0.1);
      color: #d97706;
      border: 1px solid rgba(245, 158, 11, 0.2);
    }

    .certificate-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
    }

    .certificate-detail {
      display: flex;
      flex-direction: column;
    }

    .certificate-detail-label {
      font-weight: 600;
      color: #4a5568;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }

    .certificate-detail-value {
      color: #2d3748;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.95rem;
      font-weight: 500;
    }

    .certificate-detail-value.success {
      color: #16a34a;
    }

    .certificate-detail-value.warning {
      color: #d97706;
    }

    .certificate-detail-value.error {
      color: #dc2626;
    }

    .letsencrypt-info {
      background: #f7fafc;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
      border: 1px solid #e2e8f0;
    }

    .letsencrypt-info h4 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .letsencrypt-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      font-size: 0.9rem;
    }

    .letsencrypt-detail {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
    }

    .letsencrypt-detail .label {
      color: #4a5568;
      font-weight: 500;
    }

    .letsencrypt-detail .value {
      color: #2d3748;
      font-weight: 600;
    }

    /* Geolocation heatmap */
    #geo-heatmap {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      margin-bottom: 2rem;
    }

    /* Utility classes */
    .loading {
      text-align: center;
      color: #718096;
      font-style: italic;
    }

    .error {
      background: #fed7d7;
      color: #742a2a;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .success {
      background: #c6f6d5;
      color: #22543d;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1rem 1.5rem;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.3s ease;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background: #48bb78;
    }

    .notification.error {
      background: #f56565;
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }

      .header h1 {
        font-size: 2rem;
      }

      .process-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
        min-height: auto;
        padding: 0.75rem;
      }

      .process-info {
        min-height: auto;
        width: 100%;
      }

      .process-actions {
        flex-wrap: wrap;
        gap: 0.5rem;
        width: 100%;
        justify-content: flex-start;
        min-height: auto;
      }

      .btn {
        height: 2.25rem;
        min-width: 70px;
        font-size: 0.85rem;
        padding: 0.4rem 0.8rem;
      }

      .process-details {
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
        justify-content: flex-start;
      }

      .process-details span {
        font-size: 0.85rem;
        height: 1.4rem;
        padding: 0.2rem 0.4rem;
        width: 100%;
        justify-content: flex-start;
      }

      .routes-table {
        font-size: 0.8rem;
      }

      .routes-table th,
      .routes-table td {
        padding: 0.5rem;
      }

      .letsencrypt-details {
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }

      .letsencrypt-detail {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
      }

      /* New Let's Encrypt config mobile styles */
      .letsencrypt-config {
        padding: 1rem;
        margin-bottom: 1.5rem;
      }

      .letsencrypt-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }

      .letsencrypt-title {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .letsencrypt-title h3 {
        font-size: 1.25rem;
      }

      .letsencrypt-grid {
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }

      .letsencrypt-item {
        padding: 0.75rem;
      }

      .certificate-summary {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
      }

      .certificate-summary-item {
        padding: 0.75rem;
      }

      .certificate-summary-number {
        font-size: 1.5rem;
      }

      /* Route cards mobile styles */
      .route-card {
        padding: 1rem;
        margin-bottom: 0.75rem;
      }

      .route-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .route-domain {
        font-size: 1.1rem;
      }

      .route-stats {
        text-align: left;
        width: 100%;
      }

      .route-details {
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }

      .route-detail-value {
        gap: 0.25rem;
      }

      .country-badge,
      .method-badge {
        font-size: 0.75rem;
        padding: 0.2rem 0.5rem;
      }
    }

    /* Process tabs styles */
    .process-tabs {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }

    .process-tabs-header {
      display: flex;
      background: #f7fafc;
      border-bottom: 1px solid #e2e8f0;
      overflow-x: auto;
    }

    .process-tab {
      padding: 1rem 1.5rem;
      background: transparent;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: #4a5568;
      border-bottom: 3px solid transparent;
      white-space: nowrap;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      min-width: 120px;
    }

    .process-tab:hover {
      background: #edf2f7;
      color: #2d3748;
    }

    .process-tab.active {
      background: white;
      color: #2d3748;
      border-bottom-color: #4299e1;
    }

    .process-tab-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .process-tab-status.running {
      background: #48bb78;
    }

    .process-tab-status.stopped {
      background: #f56565;
    }

    .process-tab-status.warning {
      background: #ed8936;
    }

    .process-tab-content {
      display: none;
      padding: 1rem 0.5rem;
      margin-bottom: 0.5rem;
    }

    .process-tab-content.active {
      display: block;
    }

    .process-tab-actions {
      display: flex;
      gap: 0.25rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .process-tab-actions .btn {
      min-width: 70px;
      font-size: 0.85rem;
      padding: 0.3rem 0.7rem;
      height: 2rem;
    }

    .process-tab-info {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .process-tab-info-item {
      background: #f7fafc;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      border: 1px solid #e2e8f0;
      min-width: 120px;
      font-size: 0.85rem;
    }

    .process-tab-section {
      margin-bottom: 1rem;
    }

    .process-tab-section.collapsible {
      display: none;
    }

    .process-tab-section.collapsible.open {
      display: block;
    }

    .process-tab-info-label {
      font-size: 0.8rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }

    .process-tab-info-value {
      font-weight: 500;
      color: #2d3748;
      font-size: 0.9rem;
    }

    .process-tab-info-value.success {
      color: #38a169;
    }

    .process-tab-info-value.warning {
      color: #d69e2e;
    }

    .process-tab-info-value.error {
      color: #e53e3e;
    }

    .process-tab-info-value.time-display {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
      color: #4a5568;
      background: #f7fafc;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
      border: 1px solid #e2e8f0;
    }

    .process-tab-info-value.relative-time {
      font-style: italic;
      color: #718096;
      font-size: 0.8rem;
    }

    .process-tab-section {
      margin-bottom: 2rem;
    }

    .process-tab-section h3 {
      color: #2d3748;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .no-processes-tab {
      padding: 3rem;
      text-align: center;
      color: #718096;
    }

    .no-processes-tab h3 {
      color: #4a5568;
      margin-bottom: 0.5rem;
    }

    .process-tab-scroll {
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: #cbd5e0 #f7fafc;
    }

    .process-tab-scroll::-webkit-scrollbar {
      height: 6px;
    }

    .process-tab-scroll::-webkit-scrollbar-track {
      background: #f7fafc;
    }

    .process-tab-scroll::-webkit-scrollbar-thumb {
      background: #cbd5e0;
      border-radius: 3px;
    }

    .process-tab-scroll::-webkit-scrollbar-thumb:hover {
      background: #a0aec0;
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #48bb78;
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: #48bb78;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .follow-btn {
      background: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 3px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .follow-btn:hover {
      background: #4a5568;
    }

    .follow-btn.active {
      background: #48bb78;
      border-color: #48bb78;
      color: white;
    }

    .follow-btn.inactive {
      background: #f56565;
      border-color: #f56565;
      color: white;
    }

    .live-indicator.following {
      color: #48bb78;
    }

    .live-indicator.not-following {
      color: #f56565;
    }

    .live-indicator.not-following .live-dot {
      background: #f56565;
    }

    /* Cache Management Styles */
    .cache-controls {
      margin-bottom: 2rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .cache-tabs {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }

    .cache-tabs-header {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #e2e8f0;
    }

    .cache-tab {
      flex: 1;
      padding: 1rem;
      text-align: center;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      color: #4a5568;
      transition: all 0.2s;
      border-bottom: 3px solid transparent;
    }

    .cache-tab:hover {
      background: #e2e8f0;
      color: #2d3748;
    }

    .cache-tab.active {
      background: white;
      color: #4299e1;
      border-bottom-color: #4299e1;
    }

    .cache-tab-content {
      display: none;
      padding: 2rem;
    }

    .cache-tab-content.active {
      display: block;
    }

    .cache-section {
      margin-bottom: 2rem;
    }

    .cache-section h2 {
      color: #2d3748;
      margin-bottom: 0.5rem;
      font-size: 1.5rem;
    }

    .cache-filters {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .filter-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .filter-group label {
      font-weight: 500;
      color: #4a5568;
      white-space: nowrap;
    }

    .filter-group select {
      padding: 0.5rem;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      background: white;
      font-size: 0.9rem;
      min-width: 120px;
    }

    .cache-pagination {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .cache-pagination button {
      padding: 0.5rem 1rem;
      border: 1px solid #e2e8f0;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .cache-pagination button:hover:not(:disabled) {
      background: #f8f9fa;
    }

    .cache-pagination button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .cache-pagination span {
      font-weight: 500;
      color: #4a5568;
    }

    .cache-entry {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
      background: white;
      transition: box-shadow 0.2s;
    }

    .cache-entry:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .cache-entry-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background: #f8f9fa;
      border-bottom: 1px solid #e2e8f0;
    }

    .cache-entry-info {
      flex: 1;
    }

    .cache-entry-url {
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.25rem;
      word-break: break-all;
    }

    .cache-entry-meta {
      display: flex;
      gap: 1rem;
      font-size: 0.85rem;
      color: #718096;
      flex-wrap: wrap;
    }

    .cache-entry-actions {
      display: flex;
      gap: 0.5rem;
    }

    .cache-entry-body {
      padding: 1rem;
    }

    .cache-entry-preview {
      background: #f8f9fa;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .cache-user-card {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      background: white;
      transition: box-shadow 0.2s;
    }

    .cache-user-card:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .cache-user-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .cache-user-id {
      font-weight: 600;
      color: #2d3748;
      font-size: 1.1rem;
    }

    .cache-user-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .cache-user-stat {
      text-align: center;
      padding: 0.75rem;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .cache-user-stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #2d3748;
    }

    .cache-user-stat-label {
      font-size: 0.8rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .cache-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .cache-stat-item {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
    }

    .cache-stat-value {
      font-size: 2rem;
      font-weight: bold;
      color: #2d3748;
      margin-bottom: 0.5rem;
    }

    .cache-stat-label {
      font-size: 0.9rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .cache-stat-description {
      font-size: 0.8rem;
      color: #a0aec0;
      margin-top: 0.5rem;
    }

    .loading {
      text-align: center;
      padding: 2rem;
      color: #718096;
      font-style: italic;
    }

    .error-message {
      background: #fed7d7;
      border: 1px solid #f5c6cb;
      color: #721c24;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
    }

    .success-message {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
    }

    /* Let's Encrypt Configuration Styles */
    .letsencrypt-config {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      color: white;
      box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
      position: relative;
      overflow: hidden;
    }

    .letsencrypt-config::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="10" r="0.5" fill="white" opacity="0.1"/><circle cx="10" cy="60" r="0.5" fill="white" opacity="0.1"/><circle cx="90" cy="40" r="0.5" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
      pointer-events: none;
    }

    .letsencrypt-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      position: relative;
      z-index: 1;
    }

    .letsencrypt-title {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .letsencrypt-icon {
      font-size: 2rem;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .letsencrypt-title h3 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 700;
      color: white;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .letsencrypt-subtitle {
      margin: 0.25rem 0 0 0;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.8);
      font-weight: 400;
    }

    .letsencrypt-status-badge {
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .letsencrypt-status-badge.production {
      background: rgba(34, 197, 94, 0.2);
      color: #4ade80;
    }

    .letsencrypt-status-badge.staging {
      background: rgba(245, 158, 11, 0.2);
      color: #fbbf24;
    }

    .letsencrypt-content {
      position: relative;
      z-index: 1;
    }

    .letsencrypt-section {
      margin-bottom: 1.5rem;
    }

    .letsencrypt-section:last-child {
      margin-bottom: 0;
    }

    .letsencrypt-section h4 {
      margin: 0 0 1rem 0;
      font-size: 1rem;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .letsencrypt-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1rem;
    }

    .letsencrypt-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease;
    }

    .letsencrypt-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .letsencrypt-item-icon {
      font-size: 1.25rem;
      width: 2rem;
      height: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 6px;
    }

    .letsencrypt-item-content {
      flex: 1;
    }

    .letsencrypt-item-label {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.7);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }

    .letsencrypt-item-value {
      font-size: 0.95rem;
      font-weight: 600;
      color: white;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }

    .certificate-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
    }

    .certificate-summary-item {
      text-align: center;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease;
    }

    .certificate-summary-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
    }

    .certificate-summary-item.valid {
      border-color: rgba(34, 197, 94, 0.3);
      background: rgba(34, 197, 94, 0.1);
    }

    .certificate-summary-item.warning {
      border-color: rgba(245, 158, 11, 0.3);
      background: rgba(245, 158, 11, 0.1);
    }

    .certificate-summary-item.error {
      border-color: rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.1);
    }

    .certificate-summary-number {
      font-size: 2rem;
      font-weight: 700;
      color: white;
      margin-bottom: 0.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .certificate-summary-label {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.8);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }

    /* Route statistics styles */
    .route-card {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease;
    }

    .route-card:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    .route-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      gap: 1rem;
    }

    .route-info {
      flex: 1;
    }

    .route-domain {
      font-weight: 700;
      color: #1a202c;
      font-size: 1.25rem;
      margin-bottom: 0.5rem;
    }

    .route-target {
      color: #4a5568;
      font-size: 0.95rem;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }

    .route-stats {
      text-align: right;
    }

    .route-requests {
      font-weight: 600;
      color: #2b6cb0;
      font-size: 1.1rem;
      margin-bottom: 0.25rem;
    }

    .route-response-time {
      color: #718096;
      font-size: 0.9rem;
    }

    .route-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .route-detail {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .route-detail-label {
      font-weight: 600;
      color: #4a5568;
      font-size: 0.9rem;
    }

    .route-detail-value {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .country-badge {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .method-badge {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }

    .no-data {
      color: #a0aec0;
      font-style: italic;
      font-size: 0.9rem;
    }

    /* Time period display */
    #time-period {
      color: #718096;
      font-size: 0.9rem;
      text-align: center;
      margin-bottom: 1rem;
    }

    .route-group {
      margin-bottom: 2.5rem;
    }
    .route-group-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: #4a5568;
      margin-bottom: 1rem;
      border-left: 4px solid #667eea;
      padding-left: 0.75rem;
      letter-spacing: 0.5px;
    }
    .route-group-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
    }
    @media (max-width: 768px) {
      .route-group-cards {
        flex-direction: column;
        gap: 0.75rem;
      }
      .route-group-title {
        font-size: 1.1rem;
        margin-bottom: 0.5rem;
        padding-left: 0.5rem;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="tab-bar">
      <button class="tab active" id="tab-processes" onclick="showTab('processes')">🚀 Processes</button>
      <button class="tab" id="tab-statistics" onclick="showTab('statistics')">📊 Statistics</button>
      <button class="tab" id="tab-certificates" onclick="showTab('certificates')">🔒 Certificates</button>
      <button class="tab" id="tab-cache" onclick="showTab('cache')">💾 Cache</button>
    </div>
    
    <!-- Processes Tab -->
    <div id="content-processes" class="tab-content active">
      <div class="header">
        <h1>⚙️ Process Management</h1>
        <p>Monitor and control managed processes</p>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>Total Processes</h4>
          <div class="value" id="processes-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Running</h4>
          <div class="value" id="running-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Stopped</h4>
          <div class="value" id="stopped-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Uptime</h4>
          <div class="value" id="uptime">-</div>
        </div>
        <div class="stat-card">
          <h4>Last Updated</h4>
          <div class="value" id="last-updated">-</div>
        </div>
      </div>

      <div class="process-tabs" id="process-tabs">
        <div class="process-tabs-header process-tab-scroll" id="process-tabs-header">
          <!-- Process tabs will be generated here -->
        </div>
        <div id="process-tabs-content">
          <!-- Process tab content will be generated here -->
        </div>
      </div>
    </div>

    <!-- Statistics Tab -->
    <div id="content-statistics" class="tab-content">
      <div class="header">
        <h1>📊 HTTP Service Statistics</h1>
        <p>Monitor proxy traffic, routes, and geolocation data</p>
      </div>

      <!-- World map heatmap for geolocation statistics -->
      <div id="geo-heatmap" style="width:100%;height:500px;"></div>

      <div class="time-filter">
        <h3>Time Period</h3>
        <div class="filter-buttons">
          <button class="filter-btn active" onclick="setTimeFilter('1h')">1 Hour</button>
          <button class="filter-btn" onclick="setTimeFilter('24h')">24 Hours</button>
          <button class="filter-btn" onclick="setTimeFilter('7d')">7 Days</button>
          <button class="filter-btn" onclick="setTimeFilter('30d')">30 Days</button>
        </div>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>Total Requests</h4>
          <div class="value" id="totalRequests">-</div>
        </div>
        <div class="stat-card">
          <h4>Unique IPs</h4>
          <div class="value" id="uniqueIPs">-</div>
        </div>
        <div class="stat-card">
          <h4>Active Routes</h4>
          <div class="value" id="activeRoutes">-</div>
        </div>
        <div class="stat-card">
          <h4>Countries</h4>
          <div class="value" id="uniqueCountries">-</div>
        </div>
        <div class="stat-card">
          <h4>Avg Response Time</h4>
          <div class="value" id="avgResponseTime">-</div>
        </div>
      </div>

      <div class="routes-section">
        <h2>Route Statistics</h2>
        <div id="time-period" class="time-period-display">Loading time period...</div>
        <div id="routes-container">
          <div class="loading">Loading route statistics...</div>
        </div>
      </div>
    </div>

    <!-- Certificates Tab -->
    <div id="content-certificates" class="tab-content">
      <div class="header">
        <h1>🔒 SSL Certificates</h1>
        <p>Manage SSL certificates and Let's Encrypt configuration</p>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>SSL Certificates</h4>
          <div class="value" id="certificates-count">-</div>
        </div>
        <div class="stat-card">
          <h4>Valid Certificates</h4>
          <div class="value" id="valid-certificates">-</div>
        </div>
        <div class="stat-card">
          <h4>Expiring Soon</h4>
          <div class="value" id="expiring-soon">-</div>
        </div>
        <div class="stat-card">
          <h4>Expired</h4>
          <div class="value" id="expired-certificates">-</div>
        </div>
        <div class="stat-card">
          <h4>Let's Encrypt</h4>
          <div class="value" id="letsencrypt-status">-</div>
        </div>
      </div>

      <div class="certificates-section">
        <h2>SSL Certificates</h2>
        <p class="section-description">Let's Encrypt certificate status and expiration information</p>
        <button onclick="loadCertificates()" class="refresh-btn">🔄 Refresh Certificates</button>
        <div id="certificates-container">
          <div class="loading">Loading certificates...</div>
        </div>
      </div>
    </div>

    <!-- Cache Tab -->
    <div id="content-cache" class="tab-content">
      <div class="header">
        <h1>💾 Response Cache Management</h1>
        <p>Monitor and manage disk-based cache with in-memory MRU (100 items)</p>
      </div>

      <div class="stats-overview">
        <div class="stat-card">
          <h4>Total Entries</h4>
          <div class="value" id="cache-total-entries">-</div>
        </div>
        <div class="stat-card">
          <h4>MRU Entries</h4>
          <div class="value" id="cache-mru-entries">-</div>
        </div>
        <div class="stat-card">
          <h4>Total Size</h4>
          <div class="value" id="cache-total-size">-</div>
        </div>
        <div class="stat-card">
          <h4>Active Users</h4>
          <div class="value" id="cache-active-users">-</div>
        </div>
        <div class="stat-card">
          <h4>Cache Hit Rate</h4>
          <div class="value" id="cache-hit-rate">-</div>
        </div>
      </div>

      <div class="cache-controls">
        <button onclick="loadCacheStats()" class="refresh-btn">🔄 Refresh Stats</button>
        <button onclick="clearAllCache()" class="btn btn-stop" style="margin-left: 10px;">🗑️ Clear All Cache</button>
        <button onclick="cleanupExpiredCache()" class="btn btn-restart" style="margin-left: 10px;">🧹 Cleanup Expired</button>
      </div>

      <div class="cache-tabs">
        <div class="cache-tabs-header">
          <button class="cache-tab active" id="cache-tab-overview" onclick="switchCacheTab('overview')">📊 Overview</button>
          <button class="cache-tab" id="cache-tab-users" onclick="switchCacheTab('users')">👥 Users</button>
          <button class="cache-tab" id="cache-tab-entries" onclick="switchCacheTab('entries')">📋 Entries</button>
        </div>

        <!-- Cache Overview Tab -->
        <div id="cache-content-overview" class="cache-tab-content active">
          <div class="cache-section">
            <h2>Cache Statistics</h2>
            <div id="cache-stats-container">
              <div class="loading">Loading cache statistics...</div>
            </div>
          </div>
        </div>

        <!-- Cache Users Tab -->
        <div id="cache-content-users" class="cache-tab-content">
          <div class="cache-section">
            <h2>Cache Users</h2>
            <p class="section-description">Users with cached entries and their activity</p>
            <div id="cache-users-container">
              <div class="loading">Loading cache users...</div>
            </div>
          </div>
        </div>

        <!-- Cache Entries Tab -->
        <div id="cache-content-entries" class="cache-tab-content">
          <div class="cache-section">
            <h2>Cache Entries</h2>
            <p class="section-description">Detailed view of all cache entries with filtering</p>
            
            <div class="cache-filters">
              <div class="filter-group">
                <label for="cache-user-filter">User:</label>
                <select id="cache-user-filter" onchange="filterCacheEntries()">
                  <option value="">All Users</option>
                </select>
              </div>
              <div class="filter-group">
                <label for="cache-mru-filter">Location:</label>
                <select id="cache-mru-filter" onchange="filterCacheEntries()">
                  <option value="">All</option>
                  <option value="true">MRU Only</option>
                  <option value="false">Disk Only</option>
                </select>
              </div>
              <div class="filter-group">
                <label for="cache-entries-limit">Limit:</label>
                <select id="cache-entries-limit" onchange="loadCacheEntries()">
                  <option value="25">25</option>
                  <option value="50" selected>50</option>
                  <option value="100">100</option>
                  <option value="200">200</option>
                </select>
              </div>
            </div>

            <div class="cache-pagination">
              <button id="cache-prev-page" onclick="changeCachePage(-1)" class="btn" disabled>← Previous</button>
              <span id="cache-page-info">Page 1</span>
              <button id="cache-next-page" onclick="changeCachePage(1)" class="btn">Next →</button>
            </div>

            <div id="cache-entries-container">
              <div class="loading">Loading cache entries...</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Utility function to format timestamps in local time
    function formatLocalTime(timestamp) {
      if (!timestamp) return 'N/A';
      
      try {
        const date = new Date(timestamp);
        if (isNaN(date.getTime())) return 'Invalid Date';
        
        // Format the date in local region format
        const localDate = date.toLocaleString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
        
        // Calculate elapsed time
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);
        
        let elapsedText = '';
        if (diffDays > 0) {
          elapsedText = ` (${diffDays} day${diffDays > 1 ? 's' : ''} ago)`;
        } else if (diffHours > 0) {
          elapsedText = ` (${diffHours} hour${diffHours > 1 ? 's' : ''} ago)`;
        } else if (diffMinutes > 0) {
          elapsedText = ` (${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago)`;
        } else {
          elapsedText = ' (just now)';
        }
        
        return `${localDate}${elapsedText}`;
      } catch (error) {
        return 'Invalid Date';
      }
    }

    // Utility function to format relative time (e.g., "2 hours ago")
    function formatRelativeTime(timestamp) {
      if (!timestamp) return 'N/A';
      
      try {
        const date = new Date(timestamp);
        if (isNaN(date.getTime())) return 'Invalid Date';
        
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);
        
        if (diffDays > 0) {
          return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        } else if (diffHours > 0) {
          return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        } else if (diffMinutes > 0) {
          return `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago`;
        } else {
          return 'Just now';
        }
      } catch (error) {
        return 'Invalid Date';
      }
    }

    // Global variables
    let ws = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    const reconnectDelay = 2000;
    let processesData = [];
    let statusData = {};
    let liveUpdateIntervals = {};
    let currentTimeFilter = '24h';
    let geoHeatmapChart = null;
    let geoHeatmapLoaded = false;
    let certificatesData = {};
    let currentLogLines = 100;
    let logUpdateIntervals = {};
    let activeProcessTab = null;
    let currentLogFilter = 'all'; // 'all', 'stdout', 'stderr'
    let processLogs = {}; // Store logs for each process with stream info
    let showLogsSinceRestart = false; // Track if we should show logs since last restart
    let processLastRestartTimes = {}; // Store last restart times for each process
    let isAtBottom = true; // Track if user is at bottom of logs for auto-follow

    // Cache management variables
    let cacheData = {};
    let cacheUsers = [];
    let cacheEntries = [];
    let currentCachePage = 1;
    let cacheEntriesPerPage = 50;
    let activeCacheTab = 'overview';
    let cacheFilters = {
      user: '',
      mru: ''
    };

    // Tab switching logic
    function showTab(tab, pushState = true) {
      // Hide all tabs
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      
      // Show selected tab
      document.getElementById(`tab-${tab}`).classList.add('active');
      document.getElementById(`content-${tab}`).classList.add('active');
      
      // Load data for specific tabs
      if (tab === 'statistics') {
        if (!geoHeatmapLoaded) {
          renderGeoHeatmap();
        }
        loadStatistics();
      } else if (tab === 'certificates') {
        loadCertificates();
      } else if (tab === 'cache') {
        loadCacheStats();
      }

      // Update history state
      if (pushState) {
        const state = { tab, process: activeProcessTab };
        const url = `#${tab}` + (activeProcessTab ? `-${activeProcessTab}` : '');
        window.history.pushState(state, '', url);
      }
    }

    function switchProcessTab(processId, pushState = true) {
      // Remove active class from all tabs
      document.querySelectorAll('.process-tab').forEach(tab => {
        tab.classList.remove('active');
      });

      // Hide all tab content
      document.querySelectorAll('.process-tab-content').forEach(content => {
        content.classList.remove('active');
      });

      // Activate the selected tab
      const selectedTab = document.querySelector(`[data-process-id="${processId}"]`);
      if (selectedTab) {
        selectedTab.classList.add('active');
      }

      // Show the corresponding content
      const selectedContent = document.getElementById(`process-content-${processId}`);
      if (selectedContent) {
        selectedContent.classList.add('active');
      }

      // Update active process tab
      activeProcessTab = processId;

      // Reset "since restart" state when switching tabs
      showLogsSinceRestart = false;

      // Request logs for the active tab
      requestLogs(processId, currentLogLines);

      // Set up live updates for this process
      setupLiveUpdates(processId);

      // Update history state
      if (pushState) {
        // Find the currently active main tab
        const activeTab = document.querySelector('.tab.active');
        const tab = activeTab ? activeTab.id.replace('tab-', '') : 'processes';
        const state = { tab, process: processId };
        const url = `#${tab}-${processId}`;
        window.history.pushState(state, '', url);
      }
    }

    // Handle browser navigation (back/forward)
    window.addEventListener('popstate', (event) => {
      const state = event.state;
      if (state) {
        // Restore tab
        showTab(state.tab || 'processes', false);
        // Restore process tab if present
        if (state.tab === 'processes' && state.process) {
          switchProcessTab(state.process, false);
        }
      } else {
        // Default to processes tab
        showTab('processes', false);
      }
    });

    // On page load, restore state from URL hash or default
    window.addEventListener('DOMContentLoaded', () => {
      let tab = 'processes';
      let process = null;
      if (window.location.hash) {
        const hash = window.location.hash.replace('#', '');
        const parts = hash.split('-');
        if (parts.length > 0) tab = parts[0];
        if (parts.length > 1) process = parts.slice(1).join('-');
      }
      showTab(tab, false);
      if (tab === 'processes' && process) {
        // Wait for processesData to be loaded, then switch
        const trySwitch = () => {
          if (processesData && processesData.find(p => p.id === process)) {
            switchProcessTab(process, false);
          } else {
            setTimeout(trySwitch, 100);
          }
        };
        trySwitch();
      }
    });

    // WebSocket connection management
    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws`;
      
      ws = new WebSocket(wsUrl);
      
      ws.onopen = function() {
        console.log('WebSocket connected');
        reconnectAttempts = 0;
        updateConnectionStatus(true);
      };
      
      ws.onmessage = function(event) {
        try {
          const message = JSON.parse(event.data);
          handleWebSocketMessage(message);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };
      
      ws.onclose = function() {
        console.log('WebSocket disconnected');
        updateConnectionStatus(false);
        
        // Attempt to reconnect
        if (reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
          setTimeout(connectWebSocket, reconnectDelay);
        } else {
          console.error('Max reconnection attempts reached');
          showNotification('WebSocket connection lost. Please refresh the page.', 'error');
        }
      };
      
      ws.onerror = function(error) {
        console.error('WebSocket error:', error);
      };
    }

    function updateConnectionStatus(connected) {
      const statusElement = document.getElementById('connection-status');
      if (statusElement) {
        statusElement.textContent = connected ? '🟢 Connected' : '🔴 Disconnected';
        statusElement.className = connected ? 'connected' : 'disconnected';
      }
    }

    function handleWebSocketMessage(message) {
      switch (message.type) {
        case 'processes':
          const oldProcessesData = processesData;
          processesData = message.data;
          
          // If this is the first load, update the entire display
          if (!oldProcessesData || oldProcessesData.length === 0) {
            updateProcessesDisplay();
          } else {
            // Update individual process information without regenerating HTML
            processesData.forEach(process => {
              updateProcessInfo(process.id, process);
            });
          }
          break;
        case 'status':
          statusData = message.data;
          updateStatusDisplay();
          break;
        case 'logs':
          updateProcessLogs(message.data.processId, message.data.logs);
          break;
        case 'error':
          console.error('WebSocket error:', message.data);
          showNotification('WebSocket error: ' + message.data.message, 'error');
          break;
        case 'pong':
          // Handle ping/pong for connection health
          break;
        default:
          console.warn('Unknown WebSocket message type:', message.type);
      }
    }

    function requestLogs(processId, lines = currentLogLines) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'request_logs',
          processId: processId,
          lines: lines
        }));
      }
    }

    function setLogLines(lines) {
      if (lines === 'all') {
        currentLogLines = 'all';
      } else {
        currentLogLines = parseInt(lines);
      }
      // Update active process tab with new line count
      if (activeProcessTab) {
        requestLogs(activeProcessTab, currentLogLines);
      }
    }

    function setLogFilter(filter) {
      currentLogFilter = filter;
      // Update active process tab with new filter
      if (activeProcessTab && processLogs[activeProcessTab]) {
        updateProcessLogsDisplay(activeProcessTab, processLogs[activeProcessTab]);
      }
    }

    function setLogsSinceRestart(enabled) {
      showLogsSinceRestart = enabled;
      // Update active process tab with new setting
      if (activeProcessTab && processLogs[activeProcessTab]) {
        updateProcessLogsDisplay(activeProcessTab, processLogs[activeProcessTab]);
      }
    }

    // Update status display
    function updateStatusDisplay() {
      const processesCount = statusData.processes?.length || 0;
      const runningCount = statusData.processes?.filter(p => p.status === 'running').length || 0;
      const stoppedCount = processesCount - runningCount;
      const uptime = statusData.uptime || 0;
      const timestamp = statusData.timestamp ? formatLocalTime(statusData.timestamp) : 'N/A';

      document.getElementById('processes-count').textContent = processesCount;
      document.getElementById('running-count').textContent = runningCount;
      document.getElementById('stopped-count').textContent = stoppedCount;
      document.getElementById('uptime').textContent = formatUptime(uptime * 1000);
      document.getElementById('last-updated').textContent = timestamp;
    }

    // Update process information fields without regenerating entire HTML
    function updateProcessInfo(processId, processData) {
      const processContent = document.getElementById(`process-content-${processId}`);
      if (!processContent) return;

      // Update status
      const statusElement = processContent.querySelector('.process-tab-info-item:first-child .process-tab-info-value');
      if (statusElement) {
        const statusClass = processData.status === 'running' ? 'success' : 'error';
        const statusText = processData.status === 'running' ? 'Running' : 'Stopped';
        statusElement.className = `process-tab-info-value ${statusClass}`;
        statusElement.textContent = statusText;
      }

      // Update PID
      const pidElement = processContent.querySelector('.process-tab-info-item:nth-child(2) .process-tab-info-value');
      if (pidElement) {
        pidElement.textContent = processData.pid || 'N/A';
      }

      // Update port
      const portElement = processContent.querySelector('.process-tab-info-item:nth-child(3) .process-tab-info-value');
      if (portElement) {
        portElement.textContent = processData.port || 'N/A';
      }

      // Update restart count
      const restartElement = processContent.querySelector('.process-tab-info-item:nth-child(4) .process-tab-info-value');
      if (restartElement) {
        restartElement.className = `process-tab-info-value ${getRestartCountClass(processData.restartAttempts || 0)}`;
        restartElement.textContent = processData.restartAttempts || 0;
      }

      // Update health failures
      const healthElement = processContent.querySelector('.process-tab-info-item:nth-child(5) .process-tab-info-value');
      if (healthElement) {
        healthElement.className = `process-tab-info-value ${getRestartCountClass(processData.healthFailures || 0)}`;
        healthElement.textContent = processData.healthFailures || 0;
      }

      // Update start time
      const startTimeElement = processContent.querySelector('.process-tab-info-item:nth-child(6) .process-tab-info-value');
      if (startTimeElement) {
        startTimeElement.textContent = processData.startTime ? formatLocalTime(processData.startTime) : 'N/A';
      }

      // Update last restart time
      const lastRestartElement = processContent.querySelector('.process-tab-info-item:nth-child(7) .process-tab-info-value');
      if (lastRestartElement) {
        lastRestartElement.textContent = processData.lastRestartTime ? formatLocalTime(processData.lastRestartTime) : 'N/A';
      }

      // Update uptime
      const uptimeElement = processContent.querySelector('.process-tab-info-item:nth-child(4) .process-tab-info-value');
      if (uptimeElement) {
        uptimeElement.textContent = processData.uptime ? formatUptime(processData.uptime) : 'N/A';
      }

      // Update restart history section
      const restartHistorySection = processContent.querySelector('.process-tab-section:first-of-type .process-tab-info');
      if (restartHistorySection) {
        // Update current session restarts
        const currentSessionElement = restartHistorySection.querySelector('.process-tab-info-item:first-child .process-tab-info-value');
        if (currentSessionElement) {
          currentSessionElement.textContent = `${processData.restartAttempts || 0} restarts`;
        }

        // Update last restart time in history section
        const lastRestartHistoryElement = restartHistorySection.querySelector('.process-tab-info-item:nth-child(2) .process-tab-info-value');
        if (lastRestartHistoryElement && processData.lastRestartTime) {
          lastRestartHistoryElement.textContent = formatLocalTime(processData.lastRestartTime);
        }

        // Update reconnected status
        const reconnectedElement = restartHistorySection.querySelector('.process-tab-info-item:last-child .process-tab-info-value');
        if (reconnectedElement && processData.isReconnected) {
          reconnectedElement.textContent = `Existing PID: ${processData.pid}`;
        }
      }

      // Update tab header status indicator
      const tabButton = document.querySelector(`[data-process-id="${processId}"]`);
      if (tabButton) {
        const statusIndicator = tabButton.querySelector('.process-tab-status');
        if (statusIndicator) {
          statusIndicator.className = `process-tab-status ${processData.status === 'running' ? 'running' : 'stopped'}`;
        }
      }

      // Update action buttons
      const startButton = processContent.querySelector('.btn-start');
      const stopButton = processContent.querySelector('.btn-stop');
      
      if (startButton) {
        startButton.disabled = processData.status === 'running';
      }
      if (stopButton) {
        stopButton.disabled = processData.status !== 'running';
      }
    }

    // Update processes display
    function updateProcessesDisplay() {
      const tabsHeader = document.getElementById('process-tabs-header');
      const tabsContent = document.getElementById('process-tabs-content');
      
      if (!processesData || processesData.length === 0) {
        tabsHeader.innerHTML = '';
        tabsContent.innerHTML = `
          <div class="no-processes-tab">
            <h3>No Processes Configured</h3>
            <p>No processes are currently configured or available.</p>
          </div>
        `;
        return;
      }

      // Preserve current active tab
      const currentActiveTab = activeProcessTab || (processesData.length > 0 ? processesData[0].id : null);

      // Generate tab headers
      const tabHeaders = processesData.map((process) => {
        const statusClass = process.status === 'running' ? 'running' : 'stopped';
        const isActive = process.id === currentActiveTab ? 'active' : '';
        
        return `
          <button class="process-tab ${isActive}" data-process-id="${process.id}" onclick="switchProcessTab('${process.id}')">
            <div class="process-tab-status ${statusClass}"></div>
            <span>${process.name || process.id}</span>
          </button>
        `;
      }).join('');

      // Generate tab content
      const tabContents = processesData.map((process) => {
        const isActive = process.id === currentActiveTab ? 'active' : '';
        const statusClass = process.status === 'running' ? 'success' : 'error';
        const statusText = process.status === 'running' ? 'Running' : 'Stopped';
        
        return `
          <div class="process-tab-content ${isActive}" id="process-content-${process.id}">
            <div class="process-tab-actions">
              <button onclick="startProcess('${process.id}')" class="btn btn-start" ${process.status === 'running' ? 'disabled' : ''}>
                Start
              </button>
              <button onclick="stopProcess('${process.id}')" class="btn btn-stop" ${process.status !== 'running' ? 'disabled' : ''}>
                Stop
              </button>
              <button onclick="restartProcess('${process.id}')" class="btn btn-restart">
                Restart
              </button>
            </div>
            <div class="process-tab-info">
              <div class="process-tab-info-item">
                <span class="process-tab-info-label">Status</span>
                <span class="process-tab-info-value ${statusClass}">${statusText}</span>
              </div>
              <div class="process-tab-info-item">
                <span class="process-tab-info-label">PID</span>
                <span class="process-tab-info-value">${process.pid || 'N/A'}</span>
              </div>
              <div class="process-tab-info-item">
                <span class="process-tab-info-label">Port</span>
                <span class="process-tab-info-value">${process.port || 'N/A'}</span>
              </div>
              <div class="process-tab-info-item">
                <span class="process-tab-info-label">Uptime</span>
                <span class="process-tab-info-value">${process.uptime ? formatUptime(process.uptime) : 'N/A'}</span>
              </div>
              <button class="btn btn-xs" onclick="toggleDetails('${process.id}')" style="margin-left: 1rem;">Details</button>
            </div>
            <div class="process-tab-section collapsible" id="details-${process.id}">
              <div class="process-tab-info">
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Restart Count</span>
                  <span class="process-tab-info-value ${getRestartCountClass(process.restartAttempts || 0)}">${process.restartAttempts || 0}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Health Failures</span>
                  <span class="process-tab-info-value ${getRestartCountClass(process.healthFailures || 0)}">${process.healthFailures || 0}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Start Time</span>
                  <span class="process-tab-info-value time-display">${process.startTime ? formatLocalTime(process.startTime) : 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Last Restart</span>
                  <span class="process-tab-info-value time-display">${process.lastRestartTime ? formatLocalTime(process.lastRestartTime) : 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">Log File</span>
                  <span class="process-tab-info-value" style="font-size: 0.8rem;">${process.logFile || 'N/A'}</span>
                </div>
                <div class="process-tab-info-item">
                  <span class="process-tab-info-label">PID File</span>
                  <span class="process-tab-info-value" style="font-size: 0.8rem;">${process.pidFile || 'N/A'}</span>
                </div>
              </div>
            </div>
            <div class="process-tab-section">
              <h3>📋 Process Logs</h3>
              <div class="logs-container" id="logs-${process.id}">
                <div class="logs-header">
                  <div class="logs-title">Process Logs</div>
                  <div class="logs-controls">
                    <select onchange="setLogLines(this.value)" title="Number of log lines to display">
                      <option value="100">100 lines</option>
                      <option value="500">500 lines</option>
                      <option value="1000">1,000 lines</option>
                      <option value="5000">5,000 lines</option>
                      <option value="10000">10,000 lines</option>
                      <option value="all">All logs</option>
                    </select>
                    <div class="logs-filter-buttons">
                      <button class="logs-filter-btn all active" onclick="setLogFilter('all')" title="Show all logs">All</button>
                      <button class="logs-filter-btn stdout" onclick="setLogFilter('stdout')" title="Show stdout only">STDOUT</button>
                      <button class="logs-filter-btn stderr" onclick="setLogFilter('stderr')" title="Show stderr only">STDERR</button>
                      <button class="logs-filter-btn logs-since-restart" onclick="setLogsSinceRestart(!showLogsSinceRestart)" title="Show logs since last restart">Since Restart</button>
                    </div>
                    <button class="follow-btn active" onclick="scrollToBottom('${process.id}')" title="Follow logs (scroll to bottom)">
                      <span>📋</span>
                      <span>Follow</span>
                    </button>
                    <div class="live-indicator following">
                      <div class="live-dot"></div>
                      <span>Live</span>
                    </div>
                  </div>
                </div>
                <div class="logs-loading">Click tab to load recent log entries</div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      tabsHeader.innerHTML = tabHeaders;
      tabsContent.innerHTML = tabContents;

      // Update active process tab if it changed
      if (currentActiveTab && currentActiveTab !== activeProcessTab) {
        activeProcessTab = currentActiveTab;
        // Request logs for the active tab if it's the first time
        if (!processLogs[currentActiveTab]) {
          requestLogs(currentActiveTab, currentLogLines);
          setupLiveUpdates(currentActiveTab);
        }
      } else if (!activeProcessTab && processesData.length > 0) {
        // Set the first process as active if no active tab
        switchProcessTab(processesData[0].id);
      }
    }

    // Process control functions
    async function startProcess(processId) {
      await performProcessAction(processId, 'start');
    }

    async function stopProcess(processId) {
      await performProcessAction(processId, 'stop');
    }

    async function restartProcess(processId) {
      await performProcessAction(processId, 'restart');
    }

    async function performProcessAction(processId, action) {
      try {
        const response = await fetch(`/api/processes/${processId}/${action}`, {
          method: 'POST'
        });

        const data = await response.json();

        if (data.success) {
          showNotification(`Process ${processId} ${action}ed successfully`, 'success');
          // WebSocket will automatically update the display
        } else {
          showNotification(`Failed to ${action} process: ` + data.error, 'error');
        }
      } catch (error) {
        showNotification(`Failed to ${action} process: ` + error.message, 'error');
      }
    }

    // Update process logs via WebSocket
    function updateProcessLogs(processId, logs) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) {
        return;
      }

      // Store last restart time for this process
      const process = processesData.find(p => p.id === processId);
      if (process && process.lastRestartTime) {
        processLastRestartTimes[processId] = new Date(process.lastRestartTime).getTime();
      }

      if (!logs || logs.length === 0) {
        logsContainer.innerHTML = `
          <div class="logs-header">
            <div class="logs-title">Process Logs</div>
            <div class="logs-controls">
              <select onchange="setLogLines(this.value)" title="Number of log lines to display">
                <option value="100">100 lines</option>
                <option value="500">500 lines</option>
                <option value="1000">1,000 lines</option>
                <option value="5000">5,000 lines</option>
                <option value="10000">10,000 lines</option>
                <option value="all">All logs</option>
              </select>
              <div class="logs-filter-buttons">
                <button class="logs-filter-btn all active" onclick="setLogFilter('all')" title="Show all logs">All</button>
                <button class="logs-filter-btn stdout" onclick="setLogFilter('stdout')" title="Show stdout only">STDOUT</button>
                <button class="logs-filter-btn stderr" onclick="setLogFilter('stderr')" title="Show stderr only">STDERR</button>
                <button class="logs-filter-btn logs-since-restart" onclick="setLogsSinceRestart(!showLogsSinceRestart)" title="Show logs since last restart">Since Restart</button>
              </div>
              <button class="follow-btn active" onclick="scrollToBottom('${processId}')" title="Follow logs (scroll to bottom)">
                <span>📋</span>
                <span>Follow</span>
              </button>
              <div class="live-indicator following">
                <div class="live-dot"></div>
                <span>Live</span>
              </div>
            </div>
          </div>
          <div class="logs-loading">No logs available</div>
        `;
        return;
      }

      // Store logs with stream information
      const logsWithStreams = logs.map(log => {
        // Parse log line to determine stream type
        // Look for explicit stream prefixes first
        if (log.includes('[STDOUT]')) {
          return {
            content: log,
            stream: 'stdout'
          };
        }
        
        if (log.includes('[STDERR]')) {
          return {
            content: log,
            stream: 'stderr'
          };
        }
        
        // Fallback to pattern matching for logs without explicit prefixes
        const isStderr = log.includes('ERROR') || 
                        log.includes('WARN') ||
                        log.includes('FATAL') ||
                        log.toLowerCase().includes('error') ||
                        log.toLowerCase().includes('warning') ||
                        log.toLowerCase().includes('fail') ||
                        log.toLowerCase().includes('exception');
        
        return {
          content: log,
          stream: isStderr ? 'stderr' : 'stdout'
        };
      });

      // Store logs for this process
      processLogs[processId] = logsWithStreams;

      // Update display with current filter
      updateProcessLogsDisplay(processId, logsWithStreams);
    }

    // Update process logs display with filtering
    function updateProcessLogsDisplay(processId, logsWithStreams) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) {
        return;
      }

      // Filter logs based on current filter
      let filteredLogs = logsWithStreams.filter(log => {
        if (currentLogFilter === 'all') return true;
        return log.stream === currentLogFilter;
      });

      // Apply "since last restart" filter if enabled
      if (showLogsSinceRestart && processLastRestartTimes[processId]) {
        const lastRestartTime = processLastRestartTimes[processId];
        filteredLogs = filteredLogs.filter(log => {
          // Try to extract timestamp from log line
          const timestampMatch = log.content.match(/\[(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\]/);
          if (timestampMatch) {
            const logTime = new Date(timestampMatch[1]).getTime();
            return logTime >= lastRestartTime;
          }
          // If no timestamp found, include the log (better to show than hide)
          return true;
        });
      }

      // Update filter button states
      const filterButtons = logsContainer.querySelectorAll('.logs-filter-btn');
      filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent.toLowerCase() === currentLogFilter || 
            (currentLogFilter === 'all' && btn.textContent === 'All')) {
          btn.classList.add('active');
        }
        // Handle "Since Restart" button state
        if (btn.textContent === 'Since Restart') {
          if (showLogsSinceRestart) {
            btn.classList.add('active');
          }
        }
      });

      // Use DocumentFragment for better performance with large log volumes
      const fragment = document.createDocumentFragment();
      const logLinesContainer = document.createElement('div');
      logLinesContainer.className = 'logs-content';

      // Process logs in chunks to avoid blocking the UI
      const chunkSize = 1000;
      const processLogsInChunks = (startIndex) => {
        const endIndex = Math.min(startIndex + chunkSize, filteredLogs.length);
        
        for (let i = startIndex; i < endIndex; i++) {
          const logLine = document.createElement('div');
          logLine.className = `log-line ${filteredLogs[i].stream}`;
          logLine.innerHTML = filteredLogs[i].content;
          logLinesContainer.appendChild(logLine);
        }

        if (endIndex < filteredLogs.length) {
          // Process next chunk asynchronously
          setTimeout(() => processLogsInChunks(endIndex), 0);
        } else {
          // All chunks processed, update the container
          const header = logsContainer.querySelector('.logs-header');
          logsContainer.innerHTML = '';
          logsContainer.appendChild(header);
          logsContainer.appendChild(logLinesContainer);
          
          // Only scroll to bottom if user was at bottom before update
          if (isAtBottom) {
            logLinesContainer.scrollTop = logLinesContainer.scrollHeight;
          }
          
          // Setup scroll listener for this log container
          setupLogScrollListener(processId);
        }
      };

      // Update header with log count
      const header = logsContainer.querySelector('.logs-header');
      if (header) {
        const title = header.querySelector('.logs-title');
        if (title) {
          const totalLogs = logsWithStreams.length;
          const filteredCount = filteredLogs.length;
          let filterText = '';
          if (currentLogFilter !== 'all') {
            filterText += ` (${currentLogFilter.toUpperCase()})`;
          }
          if (showLogsSinceRestart) {
            filterText += ' (since restart)';
          }
          
          // Add indicator for "all logs" mode
          let lineCountText = '';
          if (currentLogLines === 'all') {
            lineCountText = ` (All ${filteredCount.toLocaleString()}/${totalLogs.toLocaleString()} lines)`;
          } else {
            lineCountText = ` (${filteredCount.toLocaleString()}/${totalLogs.toLocaleString()} lines)`;
          }
          
          title.textContent = `Process Logs${filterText}${lineCountText}`;
        }
        
        // Update follow button and live indicator
        const followBtn = header.querySelector('.follow-btn');
        const liveIndicator = header.querySelector('.live-indicator');
        
        if (followBtn) {
          if (isAtBottom) {
            followBtn.className = 'follow-btn active';
            followBtn.title = 'Following logs (scroll to bottom)';
            followBtn.innerHTML = '<span>📋</span><span>Follow</span>';
          } else {
            followBtn.className = 'follow-btn inactive';
            followBtn.title = 'Not following - click to follow logs';
            followBtn.innerHTML = '<span>⏸️</span><span>Paused</span>';
          }
        }
        
        if (liveIndicator) {
          if (isAtBottom) {
            liveIndicator.className = 'live-indicator following';
            liveIndicator.innerHTML = '<div class="live-dot"></div><span>Live</span>';
          } else {
            liveIndicator.className = 'live-indicator not-following';
            liveIndicator.innerHTML = '<div class="live-dot"></div><span>Paused</span>';
          }
        }
        
        // Update dropdown selection
        const lineCountSelect = header.querySelector('select');
        if (lineCountSelect) {
          lineCountSelect.value = currentLogLines;
        }
      }

      // Start processing logs
      processLogsInChunks(0);
      
      // Show performance warning for very large log files
      if (currentLogLines === 'all' && filteredLogs.length > 50000) {
        setTimeout(() => {
          const warningDiv = document.createElement('div');
          warningDiv.className = 'logs-warning';
          warningDiv.innerHTML = `
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 4px; padding: 0.75rem; margin: 0.5rem 0; color: #92400e;">
              <strong>⚠️ Performance Notice:</strong> Displaying ${filteredLogs.length.toLocaleString()} log lines. 
              Large log files may impact browser performance. Consider using a smaller line count for better performance.
            </div>
          `;
          logsContainer.insertBefore(warningDiv, logsContainer.firstChild);
        }, 100);
      }
    }

    // Start live log updates for a process
    function setupLiveUpdates(processId) {
      // Stop live updates for other processes
      Object.keys(logUpdateIntervals).forEach(pid => {
        if (pid !== processId) {
          stopLiveLogUpdates(pid);
        }
      });

      // Start live updates for the current process
      startLiveLogUpdates(processId);
    }

    function startLiveLogUpdates(processId) {
      // Stop any existing interval for this process
      stopLiveLogUpdates(processId);
      
      // Request logs every 5 seconds via WebSocket
      logUpdateIntervals[processId] = setInterval(() => {
        requestLogs(processId, currentLogLines);
      }, 5000);
    }

    // Stop live log updates for a process
    function stopLiveLogUpdates(processId) {
      if (logUpdateIntervals[processId]) {
        clearInterval(logUpdateIntervals[processId]);
        delete logUpdateIntervals[processId];
      }
    }

    // Statistics functions
    function setTimeFilter(period) {
      currentTimeFilter = period;
      
      // Update active button
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      loadStatistics();
      if (geoHeatmapLoaded) {
        renderGeoHeatmap();
      }
    }

    async function loadStatistics() {
      try {
        const response = await fetch(`/api/statistics?period=${currentTimeFilter}`);
        const data = await response.json();
        
        if (data.success) {
          updateStatisticsDisplay(data.data);
        } else {
          console.error('Failed to load statistics:', data.error);
        }
      } catch (error) {
        console.error('Error loading statistics:', error);
      }
    }

    function updateStatisticsDisplay(data) {
      // Update overview cards using summary data
      const summary = data.summary || {};
      document.getElementById('totalRequests').textContent = formatNumber(summary.totalRequests || 0);
      document.getElementById('uniqueIPs').textContent = formatNumber(summary.uniqueIPs || 0);
      document.getElementById('uniqueCountries').textContent = formatNumber(summary.uniqueCountries || 0);
      
      // Handle average response time - could be in data.avgResponseTime or calculated from details
      let avgResponseTime = data.avgResponseTime || 0;
      if (!avgResponseTime && data.details && data.details.byIP && data.details.byIP.length > 0) {
        const totalResponseTimes = data.details.byIP.reduce((sum, ipStat) => {
          // If responseTimes is available in the data, use it
          if (ipStat.responseTimes && Array.isArray(ipStat.responseTimes)) {
            return sum + ipStat.responseTimes.reduce((ipSum, time) => ipSum + time, 0);
          }
          return sum;
        }, 0);
        const totalRequests = data.details.byIP.reduce((sum, ipStat) => sum + ipStat.count, 0);
        avgResponseTime = totalRequests > 0 ? totalResponseTimes / totalRequests : 0;
      }
      document.getElementById('avgResponseTime').textContent = avgResponseTime > 0 ? `${avgResponseTime.toFixed(2)}ms` : 'N/A';

      // Update route statistics
      const routesContainer = document.getElementById('routes-container');
      if (data.routes && Array.isArray(data.routes) && data.routes.length > 0) {
        // Group routes by name
        const groups = {};
        data.routes.forEach(route => {
          const groupName = route.name || 'Other';
          if (!groups[groupName]) groups[groupName] = [];
          groups[groupName].push(route);
        });
        
        const groupHtml = Object.entries(groups).map(([name, routes]) => {
          const cardsHtml = routes.map(route => {
            const topCountriesHtml = route.topCountries && route.topCountries.length > 0 
              ? route.topCountries.slice(0, 3).map(country => 
                  `<span class="country-badge">${country.country} (${country.count})</span>`
                ).join('')
              : '<span class="no-data">No country data</span>';
            
            const methodsHtml = route.methods && route.methods.length > 0
              ? route.methods.map(method => `<span class="method-badge">${method}</span>`).join('')
              : '<span class="no-data">No method data</span>';
            
            return `
              <div class="route-card">
                <div class="route-header">
                  <div class="route-info">
                    <div class="route-domain">${route.domain || 'Unknown'}</div>
                    <div class="route-target">${route.target || 'Unknown'}</div>
                  </div>
                  <div class="route-stats">
                    <div class="route-requests">${formatNumber(route.requests)} requests</div>
                    <div class="route-response-time">${route.avgResponseTime > 0 ? route.avgResponseTime.toFixed(2) + 'ms' : 'N/A'}</div>
                  </div>
                </div>
                <div class="route-details">
                  <div class="route-detail">
                    <div class="route-detail-label">Top Countries:</div>
                    <div class="route-detail-value">${topCountriesHtml}</div>
                  </div>
                  <div class="route-detail">
                    <div class="route-detail-label">Methods:</div>
                    <div class="route-detail-value">${methodsHtml}</div>
                  </div>
                  <div class="route-detail">
                    <div class="route-detail-label">Unique IPs:</div>
                    <div class="route-detail-value">${route.uniqueIPs || 0}</div>
                  </div>
                </div>
              </div>
            `;
          }).join('');
          return `
            <div class="route-group">
              <h3 class="route-group-title">${name}</h3>
              <div class="route-group-cards">${cardsHtml}</div>
            </div>
          `;
        }).join('');
        
        routesContainer.innerHTML = groupHtml;
      } else {
        routesContainer.innerHTML = '<div class="no-data">No route statistics available for the selected time period</div>';
      }

      // Update time period display
      if (data.period) {
        const startDate = new Date(data.period.start).toLocaleString();
        const endDate = new Date(data.period.end).toLocaleString();
        document.getElementById('time-period').textContent = `${startDate} - ${endDate}`;
      }
    }

    async function renderGeoHeatmap() {
      const container = document.getElementById('geo-heatmap');
      container.innerHTML = '';
      
      if (!window.echarts) {
        container.innerHTML = '<div style="color:#e53e3e;padding:2rem;text-align:center;">ECharts library not loaded</div>';
        return;
      }
      
      if (!geoHeatmapChart) {
        geoHeatmapChart = echarts.init(container);
      }
      
      geoHeatmapChart.showLoading('default', { text: 'Loading geolocation statistics...' });

      try {
        const res = await fetch(`/api/statistics?period=${currentTimeFilter}`);
        const data = await res.json();
        
        if (!data.success) {
          throw new Error('Failed to load statistics');
        }
        
        // Aggregate country counts from the actual data structure
        const countryCounts = {};
        
        // Try to get data from routes (time period stats)
        if (data.data.routes && Array.isArray(data.data.routes)) {
          data.data.routes.forEach(route => {
            (route.topCountries || []).forEach(country => {
              if (country.country && country.country !== 'Unknown') {
                countryCounts[country.country] = (countryCounts[country.country] || 0) + country.count;
              }
            });
          });
        }
        
        // If no routes data, try to get from summary
        if (Object.keys(countryCounts).length === 0 && data.data.summary && data.data.summary.topCountries) {
          data.data.summary.topCountries.forEach(country => {
            if (country.country && country.country !== 'Unknown') {
              countryCounts[country.country] = country.count;
            }
          });
        }
        
        // If still no data, try to get from details
        if (Object.keys(countryCounts).length === 0 && data.data.details && data.data.details.byIP) {
          data.data.details.byIP.forEach(ipStat => {
            if (ipStat.location && ipStat.location !== 'Unknown') {
              const country = ipStat.location.split(', ').pop(); // Get last part (country)
              if (country && country !== 'Unknown') {
                countryCounts[country] = (countryCounts[country] || 0) + ipStat.count;
              }
            }
          });
        }
        
        // If still no data, try to get from the raw stats data
        if (Object.keys(countryCounts).length === 0 && data.data.stats) {
          data.data.stats.forEach(stat => {
            if (stat.geolocation && stat.geolocation.country && stat.geolocation.country !== 'Unknown') {
              countryCounts[stat.geolocation.country] = (countryCounts[stat.geolocation.country] || 0) + stat.count;
            }
          });
        }
        
        // Convert to ECharts format
        const mapData = Object.entries(countryCounts).map(([country, count]) => ({ 
          name: country, 
          value: count 
        }));
        
        if (mapData.length === 0) {
          container.innerHTML = '<div style="color:#718096;padding:2rem;text-align:center;">No geolocation data available for the selected time period</div>';
          return;
        }
        
        geoHeatmapChart.setOption({
          title: {
            text: `Geolocation Heatmap (${currentTimeFilter})`,
            left: 'center',
            top: 10,
            textStyle: { fontSize: 20 }
          },
          tooltip: {
            trigger: 'item',
            formatter: params => `${params.name}: ${params.value || 0} requests`
          },
          visualMap: {
            min: 0,
            max: Math.max(10, ...mapData.map(d => d.value)),
            text: ['High','Low'],
            realtime: false,
            calculable: true,
            inRange: {
              color: ['#e0f3f8','#abd9e9','#74add1','#4575b4','#313695','#a50026']
            },
            left: 'left',
            bottom: 30
          },
          series: [{
            name: 'Requests',
            type: 'map',
            map: 'world',
            roam: true,
            emphasis: { label: { show: true } },
            data: mapData
          }]
        });
        
        geoHeatmapChart.hideLoading();
        geoHeatmapLoaded = true;
      } catch (err) {
        console.error('Error rendering heatmap:', err);
        container.innerHTML = '<div style="color:#e53e3e;padding:2rem;text-align:center;">Failed to load geolocation statistics</div>';
      }
    }

    // Certificate functions
    async function loadCertificates() {
      try {
        const response = await fetch('/api/certificates');
        const data = await response.json();

        if (data.success) {
          certificatesData = data.data;
          updateCertificatesDisplay();
        } else {
          console.error('Failed to load certificates:', data.error);
        }
      } catch (error) {
        console.error('Failed to load certificates:', error);
      }
    }

    function updateCertificatesDisplay() {
      const { certificates, letsEncryptStatus } = certificatesData;

      // Update status cards
      document.getElementById('certificates-count').textContent = letsEncryptStatus.totalCertificates;
      document.getElementById('valid-certificates').textContent = letsEncryptStatus.validCertificates;
      document.getElementById('expiring-soon').textContent = letsEncryptStatus.expiringSoon;
      document.getElementById('expired-certificates').textContent = letsEncryptStatus.expired;
      
      const letsEncryptMode = letsEncryptStatus.staging ? 'Staging' : 'Production';
      document.getElementById('letsencrypt-status').textContent = letsEncryptMode;

      // Update certificates table
      const container = document.getElementById('certificates-container');
      
      if (!certificates || certificates.length === 0) {
        container.innerHTML = '<div class="no-data">No certificates found</div>';
        return;
      }

      const letsEncryptInfo = `
        <div class="letsencrypt-config">
          <div class="letsencrypt-header">
            <div class="letsencrypt-title">
              <div class="letsencrypt-icon">🔒</div>
              <div>
                <h3>Let's Encrypt Configuration</h3>
                <p class="letsencrypt-subtitle">SSL Certificate Management</p>
              </div>
            </div>
            <div class="letsencrypt-status-badge ${letsEncryptStatus.staging ? 'staging' : 'production'}">
              ${letsEncryptStatus.staging ? 'Staging' : 'Production'}
            </div>
          </div>
          
          <div class="letsencrypt-content">
            <div class="letsencrypt-section">
              <h4>Account Information</h4>
              <div class="letsencrypt-grid">
                <div class="letsencrypt-item">
                  <div class="letsencrypt-item-icon">📧</div>
                  <div class="letsencrypt-item-content">
                    <div class="letsencrypt-item-label">Email</div>
                    <div class="letsencrypt-item-value">${letsEncryptStatus.email}</div>
                  </div>
                </div>
                <div class="letsencrypt-item">
                  <div class="letsencrypt-item-icon">📁</div>
                  <div class="letsencrypt-item-content">
                    <div class="letsencrypt-item-label">Certificate Directory</div>
                    <div class="letsencrypt-item-value">${letsEncryptStatus.certDir}</div>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="letsencrypt-section">
              <h4>Certificate Summary</h4>
              <div class="certificate-summary">
                <div class="certificate-summary-item">
                  <div class="certificate-summary-number">${letsEncryptStatus.totalCertificates}</div>
                  <div class="certificate-summary-label">Total</div>
                </div>
                <div class="certificate-summary-item valid">
                  <div class="certificate-summary-number">${letsEncryptStatus.validCertificates}</div>
                  <div class="certificate-summary-label">Valid</div>
                </div>
                <div class="certificate-summary-item warning">
                  <div class="certificate-summary-number">${letsEncryptStatus.expiringSoon}</div>
                  <div class="certificate-summary-label">Expiring Soon</div>
                </div>
                <div class="certificate-summary-item error">
                  <div class="certificate-summary-number">${letsEncryptStatus.expired}</div>
                  <div class="certificate-summary-label">Expired</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;

      const certificatesHtml = certificates.map(cert => {
        const now = new Date();
        const expiryDate = new Date(cert.expiresAt);
        const daysUntilExpiry = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));
        
        let status = 'valid';
        let statusText = 'Valid';
        
        if (expiryDate < now) {
          status = 'expired';
          statusText = 'Expired';
        } else if (daysUntilExpiry <= 30) {
          status = 'expiring-soon';
          statusText = `Expires in ${daysUntilExpiry} days`;
        }
        
        return `
          <div class="certificate-card">
            <div class="certificate-header">
              <div class="certificate-info">
                <div class="certificate-name">${cert.domain}</div>
                <div class="certificate-path">${cert.certPath}</div>
              </div>
              <div class="certificate-status ${status}">${statusText}</div>
            </div>
            <div class="certificate-details">
              <div class="certificate-detail">
                <div class="certificate-detail-label">Valid Until</div>
                <div class="certificate-detail-value">${new Date(cert.expiresAt).toLocaleString()}</div>
              </div>
              <div class="certificate-detail">
                <div class="certificate-detail-label">Days Until Expiry</div>
                <div class="certificate-detail-value ${daysUntilExpiry <= 30 ? 'warning' : daysUntilExpiry <= 0 ? 'error' : 'success'}">${daysUntilExpiry}</div>
              </div>
              <div class="certificate-detail">
                <div class="certificate-detail-label">Status</div>
                <div class="certificate-detail-value ${cert.isValid ? 'success' : 'error'}">${cert.isValid ? 'Valid' : 'Invalid'}</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = letsEncryptInfo + certificatesHtml;
    }

    // Utility functions
    function formatUptime(milliseconds) {
      const seconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) return `${days}d ${hours % 24}h`;
      if (hours > 0) return `${hours}h ${minutes % 60}m`;
      if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
      return `${seconds}s`;
    }

    function getRestartCountClass(count) {
      if (count === 0) return 'success';
      if (count <= 3) return 'warning';
      return 'error';
    }

    function formatNumber(num) {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      }
      return num.toString();
    }

    function formatResponseTime(ms) {
      if (ms < 1000) {
        return ms.toFixed(0) + 'ms';
      } else {
        return (ms / 1000).toFixed(2) + 's';
      }
    }

    function showNotification(message, type) {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;

      document.body.appendChild(notification);

      setTimeout(() => notification.classList.add('show'), 100);
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 3000);
    }

    // Clean up all live updates
    function cleanupLiveUpdates() {
      Object.keys(logUpdateIntervals).forEach(processId => {
        stopLiveLogUpdates(processId);
      });
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanupLiveUpdates);

    // Handle window resize for ECharts
    window.addEventListener('resize', () => {
      if (geoHeatmapChart) {
        geoHeatmapChart.resize();
      }
    });

    // Check if user is at bottom of logs
    function checkIfAtBottom(logsContainer) {
      if (!logsContainer) return true;
      
      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return true;
      
      const scrollTop = logLinesContainer.scrollTop;
      const scrollHeight = logLinesContainer.scrollHeight;
      const clientHeight = logLinesContainer.clientHeight;
      
      // Consider "at bottom" if within 5 pixels of the bottom
      return (scrollHeight - scrollTop - clientHeight) <= 5;
    }

    // Add scroll event listener to track when user scrolls away from bottom
    function setupLogScrollListener(processId) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) return;
      
      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return;
      
      // Remove existing listener if any
      logLinesContainer.removeEventListener('scroll', logLinesContainer._scrollHandler);
      
      // Add new scroll listener
      logLinesContainer._scrollHandler = () => {
        isAtBottom = checkIfAtBottom(logsContainer);
      };
      
      logLinesContainer.addEventListener('scroll', logLinesContainer._scrollHandler);
    }

    // Manually scroll to bottom and enable auto-follow
    function scrollToBottom(processId) {
      const logsContainer = document.getElementById(`logs-${processId}`);
      if (!logsContainer) return;
      
      const logLinesContainer = logsContainer.querySelector('.logs-content');
      if (!logLinesContainer) return;
      
      logLinesContainer.scrollTop = logLinesContainer.scrollHeight;
      isAtBottom = true;
    }

    // Initialize WebSocket connection
    connectWebSocket();

    // Add toggleDetails function for collapsible details
    function toggleDetails(processId) {
      const details = document.getElementById(`details-${processId}`);
      if (details) {
        details.classList.toggle('open');
      }
    }

    // Cache Management Functions
    function switchCacheTab(tab) {
      // Remove active class from all cache tabs
      document.querySelectorAll('.cache-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.cache-tab-content').forEach(c => c.classList.remove('active'));
      
      // Show selected tab
      document.getElementById(`cache-tab-${tab}`).classList.add('active');
      document.getElementById(`cache-content-${tab}`).classList.add('active');
      
      activeCacheTab = tab;
      
      // Load data for specific cache tabs
      if (tab === 'overview') {
        loadCacheStats();
      } else if (tab === 'users') {
        loadCacheUsers();
      } else if (tab === 'entries') {
        loadCacheEntries();
      }
    }

    async function loadCacheStats() {
      try {
        const response = await fetch('/api/cache/stats');
        if (!response.ok) throw new Error('Failed to load cache stats');
        
        const stats = await response.json();
        cacheData = stats;
        
        // Update overview stats
        document.getElementById('cache-total-entries').textContent = stats.totalEntries || 0;
        document.getElementById('cache-mru-entries').textContent = stats.mruEntries || 0;
        document.getElementById('cache-total-size').textContent = formatBytes(stats.totalSize || 0);
        document.getElementById('cache-active-users').textContent = stats.activeUsers || 0;
        document.getElementById('cache-hit-rate').textContent = `${((stats.hitRate || 0) * 100).toFixed(1)}%`;
        
        // Update detailed stats in overview tab
        if (activeCacheTab === 'overview') {
          updateCacheStatsDisplay(stats);
        }
      } catch (error) {
        console.error('Failed to load cache stats:', error);
        showNotification('Failed to load cache statistics', 'error');
      }
    }

    async function loadCacheUsers() {
      try {
        const response = await fetch('/api/cache/users');
        if (!response.ok) throw new Error('Failed to load cache users');
        
        const users = await response.json();
        cacheUsers = users;
        
        updateCacheUsersDisplay(users);
      } catch (error) {
        console.error('Failed to load cache users:', error);
        showNotification('Failed to load cache users', 'error');
      }
    }

    async function loadCacheEntries(page = 1) {
      try {
        const limit = document.getElementById('cache-entries-limit')?.value || 50;
        const userFilter = document.getElementById('cache-user-filter')?.value || '';
        const mruFilter = document.getElementById('cache-mru-filter')?.value || '';
        
        let url = `/api/cache/entries?page=${page}&limit=${limit}`;
        if (userFilter) url += `&user=${encodeURIComponent(userFilter)}`;
        if (mruFilter) url += `&mru=${mruFilter}`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to load cache entries');
        
        const data = await response.json();
        cacheEntries = data.entries || [];
        currentCachePage = page;
        
        updateCacheEntriesDisplay(data);
        updateCachePagination(data.totalPages || 1, page);
      } catch (error) {
        console.error('Failed to load cache entries:', error);
        showNotification('Failed to load cache entries', 'error');
      }
    }

    function updateCacheStatsDisplay(stats) {
      const container = document.getElementById('cache-stats-container');
      if (!container) return;
      
      const html = `
        <div class="cache-stats-grid">
          <div class="cache-stat-item">
            <div class="cache-stat-value">${stats.totalEntries || 0}</div>
            <div class="cache-stat-label">Total Entries</div>
            <div class="cache-stat-description">All cached responses</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${stats.mruEntries || 0}</div>
            <div class="cache-stat-label">MRU Entries</div>
            <div class="cache-stat-description">In-memory cache (max 100)</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${formatBytes(stats.totalSize || 0)}</div>
            <div class="cache-stat-label">Total Size</div>
            <div class="cache-stat-description">Disk storage used</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${stats.activeUsers || 0}</div>
            <div class="cache-stat-label">Active Users</div>
            <div class="cache-stat-description">Users with cached data</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${((stats.hitRate || 0) * 100).toFixed(1)}%</div>
            <div class="cache-stat-label">Hit Rate</div>
            <div class="cache-stat-description">Cache effectiveness</div>
          </div>
          <div class="cache-stat-item">
            <div class="cache-stat-value">${stats.expiredEntries || 0}</div>
            <div class="cache-stat-label">Expired Entries</div>
            <div class="cache-stat-description">Ready for cleanup</div>
          </div>
        </div>
      `;
      
      container.innerHTML = html;
    }

    function updateCacheUsersDisplay(users) {
      const container = document.getElementById('cache-users-container');
      if (!container) return;
      
      if (users.length === 0) {
        container.innerHTML = '<div class="loading">No users with cached entries found</div>';
        return;
      }
      
      const html = users.map(user => `
        <div class="cache-user-card">
          <div class="cache-user-header">
            <div class="cache-user-id">${user.userId}</div>
            <div class="cache-user-actions">
              <button onclick="clearUserCache('${user.userId}')" class="btn btn-stop">Clear User Cache</button>
            </div>
          </div>
          <div class="cache-user-stats">
            <div class="cache-user-stat">
              <div class="cache-user-stat-value">${user.entries}</div>
              <div class="cache-user-stat-label">Entries</div>
            </div>
            <div class="cache-user-stat">
              <div class="cache-user-stat-value">${formatBytes(user.size)}</div>
              <div class="cache-user-stat-label">Size</div>
            </div>
            <div class="cache-user-stat">
              <div class="cache-user-stat-value">${user.mruEntries}</div>
              <div class="cache-user-stat-label">MRU</div>
            </div>
            <div class="cache-user-stat">
              <div class="cache-user-stat-value">${formatRelativeTime(user.lastAccess)}</div>
              <div class="cache-user-stat-label">Last Access</div>
            </div>
          </div>
        </div>
      `).join('');
      
      container.innerHTML = html;
    }

    function updateCacheEntriesDisplay(data) {
      const container = document.getElementById('cache-entries-container');
      if (!container) return;
      
      const entries = data.entries || [];
      
      if (entries.length === 0) {
        container.innerHTML = '<div class="loading">No cache entries found</div>';
        return;
      }
      
      const html = entries.map(entry => `
        <div class="cache-entry">
          <div class="cache-entry-header">
            <div class="cache-entry-info">
              <div class="cache-entry-url">${entry.url}</div>
              <div class="cache-entry-meta">
                <span>User: ${entry.userId}</span>
                <span>Method: ${entry.method}</span>
                <span>Status: ${entry.status}</span>
                <span>Size: ${formatBytes(entry.size)}</span>
                <span>MRU: ${entry.inMru ? 'Yes' : 'No'}</span>
                <span>Created: ${formatRelativeTime(entry.createdAt)}</span>
                <span>Expires: ${formatRelativeTime(entry.expiresAt)}</span>
              </div>
            </div>
            <div class="cache-entry-actions">
              <button onclick="viewCacheEntry('${entry.key}')" class="btn btn-logs">View</button>
              <button onclick="deleteCacheEntry('${entry.key}')" class="btn btn-stop">Delete</button>
            </div>
          </div>
        </div>
      `).join('');
      
      container.innerHTML = html;
    }

    function updateCachePagination(totalPages, currentPage) {
      const prevBtn = document.getElementById('cache-prev-page');
      const nextBtn = document.getElementById('cache-next-page');
      const pageInfo = document.getElementById('cache-page-info');
      
      if (prevBtn) prevBtn.disabled = currentPage <= 1;
      if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
      if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
    }

    function changeCachePage(delta) {
      const newPage = currentCachePage + delta;
      if (newPage >= 1) {
        loadCacheEntries(newPage);
      }
    }

    function filterCacheEntries() {
      const userFilter = document.getElementById('cache-user-filter')?.value || '';
      const mruFilter = document.getElementById('cache-mru-filter')?.value || '';
      
      cacheFilters.user = userFilter;
      cacheFilters.mru = mruFilter;
      
      // Reset to first page when filtering
      loadCacheEntries(1);
    }

    async function clearAllCache() {
      if (!confirm('Are you sure you want to clear all cache entries? This action cannot be undone.')) {
        return;
      }
      
      try {
        const response = await fetch('/api/cache/clear', { method: 'POST' });
        if (!response.ok) throw new Error('Failed to clear cache');
        
        showNotification('All cache entries cleared successfully', 'success');
        loadCacheStats();
        if (activeCacheTab === 'users') loadCacheUsers();
        if (activeCacheTab === 'entries') loadCacheEntries(1);
      } catch (error) {
        console.error('Failed to clear cache:', error);
        showNotification('Failed to clear cache', 'error');
      }
    }

    async function cleanupExpiredCache() {
      try {
        const response = await fetch('/api/cache/cleanup', { method: 'POST' });
        if (!response.ok) throw new Error('Failed to cleanup expired cache');
        
        const result = await response.json();
        showNotification(`Cleaned up ${result.cleanedEntries || 0} expired cache entries`, 'success');
        loadCacheStats();
        if (activeCacheTab === 'users') loadCacheUsers();
        if (activeCacheTab === 'entries') loadCacheEntries(1);
      } catch (error) {
        console.error('Failed to cleanup expired cache:', error);
        showNotification('Failed to cleanup expired cache', 'error');
      }
    }

    async function clearUserCache(userId) {
      if (!confirm(`Are you sure you want to clear all cache entries for user "${userId}"?`)) {
        return;
      }
      
      try {
        const response = await fetch(`/api/cache/clear-user/${encodeURIComponent(userId)}`, { method: 'POST' });
        if (!response.ok) throw new Error('Failed to clear user cache');
        
        showNotification(`Cache cleared for user "${userId}"`, 'success');
        loadCacheStats();
        if (activeCacheTab === 'users') loadCacheUsers();
        if (activeCacheTab === 'entries') loadCacheEntries(1);
      } catch (error) {
        console.error('Failed to clear user cache:', error);
        showNotification('Failed to clear user cache', 'error');
      }
    }

    async function deleteCacheEntry(key) {
      if (!confirm('Are you sure you want to delete this cache entry?')) {
        return;
      }
      
      try {
        const response = await fetch(`/api/cache/delete/${encodeURIComponent(key)}`, { method: 'DELETE' });
        if (!response.ok) throw new Error('Failed to delete cache entry');
        
        showNotification('Cache entry deleted successfully', 'success');
        loadCacheEntries(currentCachePage);
      } catch (error) {
        console.error('Failed to delete cache entry:', error);
        showNotification('Failed to delete cache entry', 'error');
      }
    }

    async function viewCacheEntry(key) {
      try {
        const response = await fetch(`/api/cache/entry/${encodeURIComponent(key)}`);
        if (!response.ok) throw new Error('Failed to load cache entry');
        
        const entry = await response.json();
        
        // Create a modal to display the cache entry
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
          background: white;
          border-radius: 8px;
          padding: 2rem;
          max-width: 90%;
          max-height: 90%;
          overflow: auto;
          position: relative;
        `;
        
        const closeBtn = document.createElement('button');
        closeBtn.textContent = '×';
        closeBtn.style.cssText = `
          position: absolute;
          top: 1rem;
          right: 1rem;
          background: none;
          border: none;
          font-size: 2rem;
          cursor: pointer;
          color: #666;
        `;
        closeBtn.onclick = () => document.body.removeChild(modal);
        
        const preview = entry.body.length > 1000 ? 
          entry.body.substring(0, 1000) + '... [truncated]' : 
          entry.body;
        
        content.innerHTML = `
          <h2>Cache Entry: ${entry.url}</h2>
          <div style="margin-bottom: 1rem;">
            <strong>User:</strong> ${entry.userId}<br>
            <strong>Method:</strong> ${entry.method}<br>
            <strong>Status:</strong> ${entry.status}<br>
            <strong>Content-Type:</strong> ${entry.contentType}<br>
            <strong>Size:</strong> ${formatBytes(entry.size)}<br>
            <strong>Created:</strong> ${formatLocalTime(entry.createdAt)}<br>
            <strong>Expires:</strong> ${formatLocalTime(entry.expiresAt)}
          </div>
          <h3>Response Body Preview:</h3>
          <div class="cache-entry-preview">${preview}</div>
        `;
        
        content.appendChild(closeBtn);
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        // Close modal when clicking outside
        modal.onclick = (e) => {
          if (e.target === modal) {
            document.body.removeChild(modal);
          }
        };
        
      } catch (error) {
        console.error('Failed to view cache entry:', error);
        showNotification('Failed to load cache entry', 'error');
      }
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
  </script>
</body>

</html>